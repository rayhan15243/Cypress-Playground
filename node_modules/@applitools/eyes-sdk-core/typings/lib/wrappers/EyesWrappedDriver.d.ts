export = EyesWrappedDriver;
/**
 * @typedef {import('../logging/Logger')} Logger
 */
/**
 * @template TDriver, TElement, TSelector
 * @typedef {import('./EyesJsExecutor').SpecJsExecutor<TDriver, TElement, TSelector>} SpecJsExecutor
 */
/**
 * @template TDriver, TElement, TSelector
 * @typedef {import('./EyesBrowsingContext').SpecBrowsingContext<TDriver, TElement, TSelector>} SpecBrowsingContext
 */
/**
 * @template TDriver, TElement, TSelector
 * @typedef {import('./EyesElementFinder').SpecElementFinder<TDriver, TElement, TSelector>} SpecElementFinder
 */
/**
 * @template TDriver, TElement, TSelector
 * @typedef {import('./EyesDriverController').SpecDriverController<TDriver, TElement, TSelector>} SpecDriverController
 */
/**
 * @template TDriver, TElement, TSelector
 * @typedef {SpecJsExecutor<TDriver, TElement, TSelector> & SpecBrowsingContext<TDriver, TElement, TSelector> & SpecElementFinder<TDriver, TElement, TSelector> & SpecDriverController<TDriver, TElement, TSelector>} SpecDriver
 */
/**
 * @typedef DriverOverrides
 * @prop {(reference) => Promise<*>} switchToFrame
 * @prop {() => Promise<*>} switchToParentFrame
 * @prop {(url: string) => Promise<*>} visit
 */
/**
 * @template TDriver, TElement, TSelector
 * @typedef {new (logger: Logger, driver: TDriver) => TDriver & EyesWrappedDriver<TDriver, TElement, TSelector>} EyesWrappedDriverCtor
 */
/**
 * @template TDriver - TDriver provided by wrapped framework
 * @template TElement - TElement provided by wrapped framework
 * @template TSelector - TSelector supported by framework
 */
declare class EyesWrappedDriver<TDriver, TElement, TSelector> {
    /**
     * @template TDriver, TElement, TSelector
     * @param {SpecDriver<TDriver, TElement, TSelector>} spec - specifications for the specific framework
     * @param {DriverOverrides} overrides - specifications for the specific framework
     * @return {EyesWrappedDriverCtor<TDriver, TElement, TSelector>}
     */
    static specialize<TDriver_1, TElement_1, TSelector_1>(spec: import("./EyesJsExecutor").SpecJsExecutor<TDriver_1, TElement_1, TSelector_1> & import("./EyesBrowsingContext").SpecBrowsingContext<TDriver_1, TElement_1, TSelector_1> & import("./EyesElementFinder").SpecElementFinder<TDriver_1, TElement_1, TSelector_1> & import("./EyesDriverController").SpecDriverController<TDriver_1, TElement_1, TSelector_1>, overrides: DriverOverrides): new (logger: Logger, driver: TDriver_1) => TDriver_1 & EyesWrappedDriver<TDriver_1, TElement_1, TSelector_1>;
    /** @type {Object<string, Function>} */
    static get overrides(): {
        [x: string]: Function;
    };
    /**
     * @type {SpecDriver}
     */
    static get spec(): any;
    /** @type {typeof EyesJsExecutor} */
    static get JsExecutor(): typeof import("./EyesJsExecutor");
    /** @type {typeof EyesBrowsingContext} */
    static get BrowsingContext(): typeof import("./EyesBrowsingContext");
    /** @type {typeof EyesElementFinder} */
    static get ElementFinder(): typeof import("./EyesElementFinder");
    /** @type {typeof EyesDriverController} */
    static get DriverController(): typeof import("./EyesDriverController");
    /**
     * Construct wrapped driver instance and initialize all of helpers interfaces
     * @param {Logger} logger - logger instance
     * @param {TDriver} driver - specific driver object for the framework
     */
    constructor(logger: Logger, driver: TDriver);
    /** @type {Object<string, Function>} */
    get overrides(): {
        [x: string]: Function;
    };
    /** @type {SpecDriver<TDriver, TElement, TSelector>} */
    get spec(): import("./EyesJsExecutor").SpecJsExecutor<TDriver, TElement, TSelector> & import("./EyesBrowsingContext").SpecBrowsingContext<TDriver, TElement, TSelector> & import("./EyesElementFinder").SpecElementFinder<TDriver, TElement, TSelector> & import("./EyesDriverController").SpecDriverController<TDriver, TElement, TSelector>;
    /** @type {typeof EyesJsExecutor} */
    get JsExecutor(): typeof import("./EyesJsExecutor");
    /** @type {typeof EyesBrowsingContext} */
    get BrowsingContext(): typeof import("./EyesBrowsingContext");
    /** @type {typeof EyesElementFinder} */
    get ElementFinder(): typeof import("./EyesElementFinder");
    /** @type {typeof EyesDriverController} */
    get DriverController(): typeof import("./EyesDriverController");
    _logger: import("../logging/Logger");
    _driver: any;
    _executor: import("./EyesJsExecutor")<TDriver, TElement, TSelector>;
    _finder: import("./EyesElementFinder")<TDriver, TElement, TSelector>;
    _context: import("./EyesBrowsingContext")<TDriver, TElement, TSelector>;
    _controller: import("./EyesDriverController")<TDriver, TElement, TSelector>;
    _proxy: EyesWrappedDriver<TDriver, TElement, TSelector>;
    /**
     * Unwrapped driver for specific SDK
     * @type {TDriver}
     */
    get unwrapped(): TDriver;
    /**
     * Implementation of JavaScript executor interface for specific SDK
     * @type {EyesJsExecutor<TDriver, TElement, TSelector>}
     */
    get executor(): import("./EyesJsExecutor")<TDriver, TElement, TSelector>;
    /**
     * Implementation of browsing context switcher interface for specific SDK
     * @type {EyesBrowsingContext<TDriver, TElement, TSelector>}
     */
    get context(): import("./EyesBrowsingContext")<TDriver, TElement, TSelector>;
    /**
     * Implementation of element finder interface for specific SDK
     * @type {EyesElementFinder<TDriver, TElement, TSelector>}
     */
    get finder(): import("./EyesElementFinder")<TDriver, TElement, TSelector>;
    /**
     * Implementation of driver controller interface for specific SDK
     * @type {EyesDriverController<TDriver, TElement, TSelector>}
     */
    get controller(): import("./EyesDriverController")<TDriver, TElement, TSelector>;
}
declare namespace EyesWrappedDriver {
    export { Logger, SpecJsExecutor, SpecBrowsingContext, SpecElementFinder, SpecDriverController, SpecDriver, DriverOverrides, EyesWrappedDriverCtor };
}
type SpecDriver<TDriver, TElement, TSelector> = import("./EyesJsExecutor").SpecJsExecutor<TDriver, TElement, TSelector> & import("./EyesBrowsingContext").SpecBrowsingContext<TDriver, TElement, TSelector> & import("./EyesElementFinder").SpecElementFinder<TDriver, TElement, TSelector> & import("./EyesDriverController").SpecDriverController<TDriver, TElement, TSelector>;
type DriverOverrides = {
    switchToFrame: (reference: any) => Promise<any>;
    switchToParentFrame: () => Promise<any>;
    visit: (url: string) => Promise<any>;
};
type EyesWrappedDriverCtor<TDriver, TElement, TSelector> = new (logger: Logger, driver: TDriver) => TDriver & EyesWrappedDriver<TDriver, TElement, TSelector>;
type Logger = import("../logging/Logger");
type SpecJsExecutor<TDriver, TElement, TSelector> = {
    /**
     * - execute script and return result
     */
    executeScript: (driver: TDriver, script: TimerHandler, ...args: any[]) => Promise<any>;
    /**
     * - makes the driver sleep for the given amount of time in ms
     */
    sleep: (driver: TDriver, ms: number) => Promise<void>;
};
type SpecBrowsingContext<TDriver, TElement, TSelector> = {
    /**
     * - return new frame reference
     */
    createFrameReference: (reference: string | number | TElement | TSelector | import("../frames/Frame")<TDriver, TElement, TSelector> | import("./EyesWrappedElement")<TDriver, TElement, TSelector>) => any;
    /**
     * - return true if two frames are equal, false otherwise
     */
    isEqualFrames: (leftFrame: import("../frames/Frame")<TDriver, TElement, TSelector>, rightFrame: import("../frames/Frame")<TDriver, TElement, TSelector>) => Promise<boolean>;
    /**
     * - switch to frame specified with a reference
     */
    switchToFrame: (driver: TDriver, reference: string | number | TElement | TSelector | import("../frames/Frame")<TDriver, TElement, TSelector> | import("./EyesWrappedElement")<TDriver, TElement, TSelector>) => void;
    /**
     * - switch to parent frame
     */
    switchToParentFrame: (driver: TDriver) => void;
};
type SpecElementFinder<TDriver, TElement, TSelector> = {
    /**
     * - return wrapped element instance
     */
    createElement: (logger: import("../logging/Logger"), driver: EyesWrappedDriver<TDriver, TElement, TSelector>, element: TElement, selector: TSelector) => import("./EyesWrappedElement")<TDriver, TElement, TSelector>;
    /**
     * - return found element
     */
    findElement: (driver: TDriver, selector: TSelector) => TElement;
    /**
     * - return found elements
     */
    findElements: (driver: TDriver, selector: TSelector) => TElement;
    /**
     * - translate cross SDK selector to SDK specific selector
     */
    toSupportedSelector: (selector: import("./EyesWrappedElement").EyesSelector) => TSelector;
    /**
     * - translate SDK specific selector to cross SDK selector
     */
    toEyesSelector: (selector: TSelector) => import("./EyesWrappedElement").EyesSelector;
};
type SpecDriverController<TDriver, TElement, TSelector> = {
    /**
     * - return location of the window on the screen
     */
    getWindowLocation: (driver: TDriver) => Promise<{
        x: number;
        y: number;
    }>;
    /**
     * - set location of the window on the screen
     */
    setWindowLocation: (driver: TDriver, location: {
        x: number;
        y: number;
    }) => Promise<void>;
    /**
     * - return size of the window
     */
    getWindowSize: (driver: TDriver) => Promise<{
        width: number;
        height: number;
    }>;
    /**
     * - set size of the window
     */
    setWindowSize: (driver: TDriver, size: {
        width: number;
        height: number;
    }) => Promise<void>;
    /**
     * - return string which represents screen orientation
     */
    getOrientation: (driver: TDriver) => Promise<"landscape" | "portrait">;
    /**
     * - true if a mobile device, false otherwise
     */
    isMobile: (driver: TDriver) => Promise<boolean>;
    /**
     * - true if an Android device, false otherwise
     */
    isAndroid: (driver: TDriver) => Promise<boolean>;
    /**
     * - true if an iOS device, false otherwise
     */
    isIOS: (driver: TDriver) => Promise<boolean>;
    /**
     * - true if a native app, false otherwise
     */
    isNative: (driver: TDriver) => Promise<boolean>;
    /**
     * - return version of the device's platform
     */
    getPlatformVersion: (driver: TDriver) => Promise<string>;
    /**
     * - return id of the running session
     */
    getSessionId: (driver: TDriver) => Promise<string>;
    /**
     * - return screenshot of the viewport
     */
    takeScreenshot: (driver: TDriver) => Promise<string | Buffer>;
    /**
     * - return page title
     */
    getTitle: (driver: TDriver) => Promise<string>;
    /**
     * - return current url
     */
    getSource: (driver: TDriver) => Promise<string>;
    /**
     * - redirect to the specified url
     */
    visit: (driver: TDriver, url: string) => Promise<void>;
};
