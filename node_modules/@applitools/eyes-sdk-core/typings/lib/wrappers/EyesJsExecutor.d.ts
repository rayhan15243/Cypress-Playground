export = EyesJsExecutor;
/**
 * @typedef {import('../logging/Logger')} Logger
 */
/**
 * @template TDriver, TElement, TSelector
 * @typedef {import('./EyesWrappedDriver')<TDriver, TElement, TSelector>} EyesWrappedDriver
 */
/**
 * The object which implements the lowest-level functions to work with element finder
 * @template TDriver, TElement, TSelector
 * @typedef SpecJsExecutor
 * @prop {(driver: TDriver, script: string|Function, ...args) => Promise<*>} executeScript - execute script and return result
 * @prop {(driver: TDriver, ms: number) => Promise<void>} sleep - makes the driver sleep for the given amount of time in ms
 */
/**
 * @template TDriver, TElement, TSelector
 * @typedef {new (logger: Logger, driver: EyesWrappedDriver<TDriver, TElement, TSelector>) => EyesJsExecutor<TDriver, TElement, TSelector>} EyesJsExecutorCtor
 */
/**
 * @template TDriver - TDriver provided by wrapped framework
 * @template TElement - TElement provided by wrapped framework
 * @template TSelector - TSelector supported by framework
 */
declare class EyesJsExecutor<TDriver, TElement, TSelector> {
    /**
     * @template TDriver, TElement, TSelector
     * @param {SpecJsExecutor<TDriver, TElement, TSelector>} spec - specifications for the specific framework
     * @return {EyesJsExecutorCtor<TDriver, TElement, TSelector>} specialized version of this class
     */
    static specialize<TDriver_1, TElement_1, TSelector_1>(spec: SpecJsExecutor<TDriver_1, TElement_1, TSelector_1>): new (logger: Logger, driver: import("./EyesWrappedDriver")<TDriver_1, TElement_1, TSelector_1>) => EyesJsExecutor<TDriver_1, TElement_1, TSelector_1>;
    /**
     * @type {SpecsJsExecutor}
     */
    static get spec(): any;
    /**
     * Construct js executor instance
     * @param {Logger} logger - logger instance
     * @param {EyesWrappedDriver<TDriver, TElement, TSelector>} driver - wrapped driver instance
     */
    constructor(logger: Logger, driver: import("./EyesWrappedDriver")<TDriver, TElement, TSelector>);
    /** @type {SpecsJsExecutor<TDriver, TElement, TSelector>} */
    get spec(): any;
    _logger: import("../logging/Logger");
    _driver: import("./EyesWrappedDriver")<TDriver, TElement, TSelector>;
    /**
     * Schedules a command to execute JavaScript in the context of the currently selected frame or window. The script
     * fragment will be executed as the body of an anonymous function. If the script is provided as a function object,
     * that function will be converted to a string for injection into the target window.
     *
     * @param {!(string|Function)} script - script to execute
     * @param {...*} args - arguments to pass to the script
     * @return {Promise<*>} promise that will resolve to the scripts return value
     */
    executeScript(script: (string | Function), ...args: any[]): Promise<any>;
    /**
     * Schedules a command to make the driver sleep for the given amount of time
     * @param {number} ms - amount of time, in milliseconds, to sleep
     * @return {Promise<void>} promise that will be resolved when the sleep has finished
     */
    sleep(ms: number): Promise<void>;
}
declare namespace EyesJsExecutor {
    export { Logger, EyesWrappedDriver, SpecJsExecutor, EyesJsExecutorCtor };
}
/**
 * The object which implements the lowest-level functions to work with element finder
 */
type SpecJsExecutor<TDriver, TElement, TSelector> = {
    /**
     * - execute script and return result
     */
    executeScript: (driver: TDriver, script: string | Function, ...args: any[]) => Promise<any>;
    /**
     * - makes the driver sleep for the given amount of time in ms
     */
    sleep: (driver: TDriver, ms: number) => Promise<void>;
};
type EyesJsExecutorCtor<TDriver, TElement, TSelector> = new (logger: Logger, driver: import("./EyesWrappedDriver")<TDriver, TElement, TSelector>) => EyesJsExecutor<TDriver, TElement, TSelector>;
type Logger = import("../logging/Logger");
type EyesWrappedDriver<TDriver, TElement, TSelector> = import("./EyesWrappedDriver")<TDriver, TElement, TSelector>;
