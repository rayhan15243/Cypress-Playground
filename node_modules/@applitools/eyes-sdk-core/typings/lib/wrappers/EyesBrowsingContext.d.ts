export = EyesBrowsingContext;
/**
 * @typedef {import('../logging/Logger')} Logger
 */
/**
 * @template TDriver, TElement, TSelector
 * @typedef {import('./EyesWrappedDriver')<TDriver, TElement, TSelector>} EyesWrappedDriver
 */
/**
 * @template TDriver, TElement, TSelector
 * @typedef {import('../frames/Frame')<TDriver, TElement, TSelector>} Frame
 */
/**
 * @template TDriver, TElement, TSelector
 * @typedef {import('../frames/Frame').FrameReference<TDriver, TElement, TSelector>} FrameReference
 */
/**
 * The object which implements the lowest-level functions to work with browsing context
 * @template TDriver, TElement, TSelector
 * @typedef SpecBrowsingContext
 * @prop {(reference: FrameReference<TDriver, TElement, TSelector>) => Frame} createFrameReference - return new frame reference
 * @prop {(leftFrame: Frame<TDriver, TElement, TSelector>, rightFrame: Frame<TDriver, TElement, TSelector>) => Promise<boolean>} isEqualFrames - return true if two frames are equal, false otherwise
 * @prop {(driver: TDriver, reference: FrameReference<TDriver, TElement, TSelector>) => void} switchToFrame - switch to frame specified with a reference
 * @prop {(driver: TDriver) => void} switchToParentFrame - switch to parent frame
 */
/**
 * @template TDriver, TElement, TSelector
 * @typedef {new (logger: Logger, driver: EyesWrappedDriver<TDriver, TElement, TSelector>) => EyesBrowsingContext<TDriver, TElement, TSelector>} EyesBrowsingContextCtor
 */
/**
 * @template TDriver - TDriver provided by wrapped framework
 * @template TElement - TElement provided by wrapped framework
 * @template TSelector - TSelector supported by framework
 */
declare class EyesBrowsingContext<TDriver, TElement, TSelector> {
    /**
     * @template TDriver, TElement, TSelector
     * @param {SpecBrowsingContext<TDriver, TElement, TSelector>} spec - specifications for the specific framework
     * @return {EyesBrowsingContextCtor<TDriver, TElement, TSelector>} specialized version of this class
     */
    static specialize<TDriver_1, TElement_1, TSelector_1>(spec: SpecBrowsingContext<TDriver_1, TElement_1, TSelector_1>): new (logger: Logger, driver: import("./EyesWrappedDriver")<TDriver_1, TElement_1, TSelector_1>) => EyesBrowsingContext<TDriver_1, TElement_1, TSelector_1>;
    /**
     * @type {SpecBrowsingContext}
     */
    static get spec(): any;
    /**
     * Construct browsing context instance
     * @param {Logger} logger - logger instance
     * @param {EyesWrappedDriver<TDriver, TElement, TSelector>} driver - parent driver instance
     */
    constructor(logger: Logger, driver: import("./EyesWrappedDriver")<TDriver, TElement, TSelector>);
    /** @type {SpecBrowsingContext<TDriver, TElement, TSelector>} */
    get spec(): SpecBrowsingContext<TDriver, TElement, TSelector>;
    _logger: import("../logging/Logger");
    _driver: import("./EyesWrappedDriver")<TDriver, TElement, TSelector>;
    _topContext: any;
    _frameChain: import("../frames/FrameChain");
    /**
     * Representation of the top-level context
     * @type {Frame<TDriver, TElement, TSelector>}
     */
    get topContext(): import("../frames/Frame")<TDriver, TElement, TSelector>;
    /**
     * Copy of the current frame chain
     * @type {FrameChain}
     */
    get frameChain(): import("../frames/FrameChain");
    /**
     * Clear current frame chain
     */
    reset(): void;
    /**
     * Switch to the child (frame) context by reference
     * @param {FrameReference<TDriver, TElement, TSelector>} reference - reference to the frame
     * @return {Promise<void>}
     */
    frame(reference: string | number | TElement | TSelector | import("../frames/Frame")<TDriver, TElement, TSelector> | import("./EyesWrappedElement")<TDriver, TElement, TSelector>): Promise<void>;
    /**
     * Switch to the top level context
     * @return {Promise<void>}
     */
    frameDefault(): Promise<void>;
    /**
     * Switch to the parent context
     * @param {number} [elevation=1] - elevation level
     * @return {Promise<void>}
     */
    frameParent(elevation?: number): Promise<void>;
    /**
     * Switch to the specified frame path from the top level
     * @param {Iterable<FrameReference<TDriver, TElement, TSelector>>} path
     * @return {Promise<void>}
     */
    frames(path: Iterable<string | number | TElement | TSelector | import("../frames/Frame")<TDriver, TElement, TSelector> | import("./EyesWrappedElement")<TDriver, TElement, TSelector>>): Promise<void>;
    /**
     * Append the specified frame path to the current context
     * @param {Iterable<FrameReference<TDriver, TElement, TSelector>>} path
     * @return {Promise<void>}
     */
    framesAppend(path: Iterable<string | number | TElement | TSelector | import("../frames/Frame")<TDriver, TElement, TSelector> | import("./EyesWrappedElement")<TDriver, TElement, TSelector>>): Promise<void>;
    /**
     * Refresh frame chain from the real driver target context
     * @return {Promise<*>}
     */
    framesRefresh(): Promise<any>;
    /**
     * Perform an operation in the browsing context with required frame chain and return it back after operation is finished
     * @param {Iterable<FrameReference<TDriver, TElement, TSelector>>} path
     * @param {Function} operation
     * @return {Promise<any>} promise which resolve whatever an operation will resolve
     */
    framesSwitchAndReturn(framePath: any, operation: Function): Promise<any>;
    /**
     * Perform an operation in the browsing context with appended frame chain and return it back after operation is finished
     * @param {Iterable<FrameReference<TDriver, TElement, TSelector>>} path
     * @param {Function} operation
     * @return {Promise<any>} promise which resolve whatever an operation will resolve
     */
    framesAppendAndReturn(framePath: any, operation: Function): Promise<any>;
}
declare namespace EyesBrowsingContext {
    export { Logger, EyesWrappedDriver, Frame, FrameReference, SpecBrowsingContext, EyesBrowsingContextCtor };
}
/**
 * The object which implements the lowest-level functions to work with browsing context
 */
type SpecBrowsingContext<TDriver, TElement, TSelector> = {
    /**
     * - return new frame reference
     */
    createFrameReference: (reference: string | number | TElement | TSelector | import("../frames/Frame")<TDriver, TElement, TSelector> | import("./EyesWrappedElement")<TDriver, TElement, TSelector>) => any;
    /**
     * - return true if two frames are equal, false otherwise
     */
    isEqualFrames: (leftFrame: import("../frames/Frame")<TDriver, TElement, TSelector>, rightFrame: import("../frames/Frame")<TDriver, TElement, TSelector>) => Promise<boolean>;
    /**
     * - switch to frame specified with a reference
     */
    switchToFrame: (driver: TDriver, reference: string | number | TElement | TSelector | import("../frames/Frame")<TDriver, TElement, TSelector> | import("./EyesWrappedElement")<TDriver, TElement, TSelector>) => void;
    /**
     * - switch to parent frame
     */
    switchToParentFrame: (driver: TDriver) => void;
};
type FrameReference<TDriver, TElement, TSelector> = string | number | TElement | TSelector | import("../frames/Frame")<TDriver, TElement, TSelector> | import("./EyesWrappedElement")<TDriver, TElement, TSelector>;
type EyesBrowsingContextCtor<TDriver, TElement, TSelector> = new (logger: Logger, driver: import("./EyesWrappedDriver")<TDriver, TElement, TSelector>) => EyesBrowsingContext<TDriver, TElement, TSelector>;
type Logger = import("../logging/Logger");
type EyesWrappedDriver<TDriver, TElement, TSelector> = import("./EyesWrappedDriver")<TDriver, TElement, TSelector>;
type Frame<TDriver, TElement, TSelector> = import("../frames/Frame")<TDriver, TElement, TSelector>;
