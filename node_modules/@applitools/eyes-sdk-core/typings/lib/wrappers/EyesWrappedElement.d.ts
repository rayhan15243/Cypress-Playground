export = EyesWrappedElement;
/**
 * @typedef {import('../logging/Logger')} Logger
 * @typedef {import('../geometry/Region')} Region
 * @typedef {import('../geometry/Location')} Location
 * @typedef {import('../geometry/RectangleSize')} RectangleSize
 */
/**
 * @template TDriver, TElement, TSelector
 * @typedef {import('./EyesWrappedDriver')<TDriver, TElement, TSelector>} EyesWrappedDriver
 */
/**
 * Cross SDK selector
 * @typedef EyesSelector
 * @prop {'css'|'xpath'} type
 * @prop {string} selector
 */
/**
 * The object which implements the lowest-level functions to work with element
 * @template TDriver, TElement, TSelector
 * @typedef SpecElement
 * @prop {(element) => boolean} isCompatible - return true if the value is an element, false otherwise
 * @prop {(selector) => boolean} isSelector - return true if the value is a valid selector, false otherwise
 * @prop {(selector: EyesSelector) => TSelector} toSupportedSelector - translate cross SDK selector to SDK specific selector
 * @prop {(selector: TSelector) => EyesSelector} toEyesSelector - translate SDK specific selector to cross SDK selector
 * @prop {(element: EyesWrappedElement<TDriver, TElement, TSelector>) => Promise<string>} extractId - extract id from the unwrapped element
 * @prop {(element: TElement) => TElement} [extractElement] - extract an element from the supported element
 * @prop {(element: TElement) => TSelector} [extractSelector] - extract an element from the supported element
 * @prop {(result) => boolean} [isStaleElementReferenceResult] - check if is a stale element reference result
 */
/**
 * @template TDriver, TElement, TSelector
 * @typedef {new (logger?: Logger, driver?: EyesWrappedDriver<TDriver, TElement, TSelector>, element?: TElement, selector?: TSelector) => EyesWrappedElement<TDriver, TElement, TSelector>} EyesWrappedElementCtor
 */
/**
 * @template TDriver, TElement, TSelector
 * @typedef EyesWrappedElementStatics
 * @prop {(element: TElement) => EyesWrappedElement<TDriver, TElement, TSelector>} fromElement
 * @prop {(selector: TSelector) => EyesWrappedElement<TDriver, TElement, TSelector>} fromSelector
 * @prop {(element) => element is TElement} isCompatible
 * @prop {(selector) => selector is TSelector} isSelector
 * @prop {(selector: EyesSelector) => TSelector} toSupportedSelector
 * @prop {(selector: TSelector) => EyesSelector} toEyesSelector
 * @prop {(element: EyesWrappedElement<TDriver, TElement, TSelector>|TElement) => Promise<string>} extractId
 */
/**
 * @template TDriver - TDriver provided by wrapped framework
 * @template TElement - TElement provided by wrapped framework
 * @template TSelector - TSelector supported by framework
 */
declare class EyesWrappedElement<TDriver, TElement, TSelector> {
    /**
     * @template TDriver, TElement, TSelector
     * @param {SpecElement<TDriver, TElement, TSelector>} spec - specifications for the specific framework
     * @return {EyesWrappedElementCtor<TDriver, TElement, TSelector> & EyesWrappedElementStatics<TDriver, TElement, TSelector>} specialized version of this class
     */
    static specialize<TDriver_1, TElement_1, TSelector_1>(spec: SpecElement<TDriver_1, TElement_1, TSelector_1>): (new (logger?: Logger, driver?: import("./EyesWrappedDriver")<TDriver_1, TElement_1, TSelector_1>, element?: TElement_1, selector?: TSelector_1) => EyesWrappedElement<TDriver_1, TElement_1, TSelector_1>) & EyesWrappedElementStatics<TDriver_1, TElement_1, TSelector_1>;
    /**
     * @type {SpecElement}
     */
    static get spec(): any;
    /**
     * Create partial wrapped element object from the element, this object need to be initialized before use
     * @template TDriver, TElement, TSelector
     * @param {TElement} element - supported element object
     * @return {EyesWrappedElement<TDriver, TElement, TSelector>} partially wrapped object
     */
    static fromElement<TDriver_3, TElement_3, TSelector_3>(element: TElement_3): EyesWrappedElement<TDriver_3, TElement_3, TSelector_3>;
    /**
     * Create partial wrapped element object from the selector, this object need to be initialized before use
     * @template TDriver, TElement, TSelector
     * @param {TSelector} selector - any kind of supported selector
     * @return {EyesWrappedElement<TDriver, TElement, TSelector>} partially wrapped object
     */
    static fromSelector<TDriver_4, TElement_4, TSelector_4>(selector: TSelector_4): EyesWrappedElement<TDriver_4, TElement_4, TSelector_4>;
    /**
     * Check if object could be wrapped with this class
     * @template TElement
     * @param element - object to check compatibility
     * @return {element is TElement} true if object could be wrapped with this class, otherwise false
     */
    static isCompatible<TElement_5>(element: any): element is TElement_5;
    /**
     * Check if passed selector is supported by current implementation
     * @template TSelector
     * @param selector
     * @return {selector is TSelector} true if selector is supported and could be passed in the {@link EyesWrappedElement.fromSelector} implementation
     */
    static isSelector<TSelector_5>(selector: any): selector is TSelector_5;
    /**
     * Translate cross SDK selector to SDK specific selector
     * @template TSelector
     * @param {EyesSelector} selector
     * @return {TSelector} translated SDK specific selector object
     */
    static toSupportedSelector<TSelector_6>(selector: EyesSelector): TSelector_6;
    /**
     * Translate SDK specific selector to cross SDK selector
     * @template TSelector
     * @param {TSelector} selector
     * @return {EyesSelector} translated cross SDK selector object
     */
    static toEyesSelector<TSelector_7>(selector: TSelector_7): EyesSelector;
    /**
     * Extract element ID from this class instance or unwrapped element object
     * @template TDriver, TElement, TSelector
     * @param {EyesWrappedElement<TDriver, TElement, TSelector>|TElement} element - element to extract ID
     * @return {Promise<string>} if extraction is succeed returns ID of provided element, otherwise null
     */
    static extractId<TDriver_5, TElement_6, TSelector_8>(element: TElement_6 | EyesWrappedElement<TDriver_5, TElement_6, TSelector_8>): Promise<string>;
    /**
     * Compare two elements, these elements could be an instances of this class or compatible objects
     * @template TDriver, TElement, TSelector
     * @param {EyesWrappedElement<TDriver, TElement, TSelector>|TElement} leftElement - element to compare
     * @param {EyesWrappedElement<TDriver, TElement, TSelector>|TElement} rightElement - element to compare
     * @return {Promise<boolean>} true if elements are equal, false otherwise
     */
    static equals<TDriver_6, TElement_7, TSelector_9>(leftElement: TElement_7 | EyesWrappedElement<TDriver_6, TElement_7, TSelector_9>, rightElement: TElement_7 | EyesWrappedElement<TDriver_6, TElement_7, TSelector_9>): Promise<boolean>;
    /**
     * Construct a wrapped element instance. An element could be created partially, which means without drive instance,
     * Only using an element object or selector.
     * Partially created elements should be initialized by calling `EyesWrappedDriver#init` method before use.
     * @param {Logger} [logger] - logger instance
     * @param {EyesWrappedDriver<TDriver, TElement, TSelector>} [driver] - parent driver instance
     * @param {TElement} [element] - supported element object to wrap
     * @param {TSelector} [selector] - universal selector object or any kind of supported selector
     */
    constructor(logger?: Logger, driver?: import("./EyesWrappedDriver")<TDriver, TElement, TSelector>, element?: TElement, selector?: TSelector);
    /** @type {SpecElement<TDriver, TElement, TSelector>} */
    get spec(): SpecElement<TDriver, TElement, TSelector>;
    _element: TElement;
    _selector: TSelector;
    _logger: import("../logging/Logger");
    _driver: import("./EyesWrappedDriver")<TDriver, TElement, TSelector>;
    /**
     * ID of the wrapped element
     * @type {Promise<string>}
     */
    get elementId(): Promise<string>;
    /**
     * TSelector of the wrapped element
     * @type {TSelector}
     */
    get selector(): TSelector;
    /**
     * Unwrapped element
     * @type {TElement}
     */
    get unwrapped(): TElement;
    /**
     * Equality check for two elements
     * @param {EyesWrappedElement<TDriver, TElement, TSelector>|TElement} otherElement - element to compare
     * @return {Promise<boolean>} true if elements are equal, false otherwise
     */
    equals(otherElement: EyesWrappedElement<TDriver, TElement, TSelector> | TElement): Promise<boolean>;
    /**
     * Initialize element created from element or selector
     * or other kind of supported selector
     * @param {EyesWrappedDriver<TDriver, TElement, TSelector>} driver - instance of {@link EyesWrappedDriver} implementation
     * @return {Promise<this>} initialized element
     */
    init(driver: import("./EyesWrappedDriver")<TDriver, TElement, TSelector>): Promise<this>;
    /**
     * Returns element rect related to context
     * @return {Promise<Region>} rect of the element
     */
    getRect(): Promise<Region>;
    /**
     * Returns element client rect (element rect without borders) related to context
     * @return {Promise<Region>} rect of the element
     */
    getClientRect(): Promise<Region>;
    /**
     * Returns element's size
     * @return {Promise<RectangleSize>} size of the element
     */
    getSize(): Promise<RectangleSize>;
    /**
     * Returns element's location related to context
     * @return {Promise<Location>} location of the element
     */
    getLocation(): Promise<Location>;
    /**
     * Returns computed values for specified css properties
     * @param  {...string} properties - names of css properties
     * @return {Promise<string[]|string>} returns array of css values if multiple properties were specified,
     *  otherwise returns string
     */
    getCssProperty(...properties: string[]): Promise<string[] | string>;
    /**
     * Returns values for specified element's properties
     * @param  {...string} properties - names of element properties
     * @return {Promise<*[]|*>} returns array of values if multiple properties were specified,
     *  otherwise returns value
     */
    getProperty(...properties: string[]): Promise<any[] | any>;
    /**
     * Set overflow `hidden` in element's style attribute
     * @return {Promise<string>}
     */
    hideScrollbars(): Promise<string>;
    _originalOverflow: string;
    /**
     * Set original overflow in element's style attribute
     * @return {Promise<void>}
     */
    restoreScrollbars(): Promise<void>;
    /**
     * Save current element position for future restoration
     * @param {PositionProvider} - position provider which is implementing specific algorithm
     * @return {Promise<PositionMemento>} current position
     */
    preservePosition(positionProvider: any): Promise<any>;
    _positionMemento: any;
    /**
     * Restore previously saved position
     * @param {PositionProvider} - position provider which is implementing specific algorithm
     * @return {Promise<PositionMemento>} current position
     */
    restorePosition(positionProvider: any): Promise<any>;
    /**
     * Refresh an element reference with a specified element or try to refresh it by selector if so
     * @param {TElement} [freshElement] - element to update replace internal element reference
     * @return {boolean} true if element was successfully refreshed, otherwise false
     */
    refresh(freshElement?: TElement): boolean;
    /**
     * Wrap an operation on the element and handle stale element reference if such happened during operation
     * @param {Function} operation - operation on the element
     * @return {Promise<*>} promise which resolve whatever an operation will resolve
     */
    withRefresh(operation: Function): Promise<any>;
}
declare namespace EyesWrappedElement {
    export { Logger, Region, Location, RectangleSize, EyesWrappedDriver, EyesSelector, SpecElement, EyesWrappedElementCtor, EyesWrappedElementStatics };
}
/**
 * The object which implements the lowest-level functions to work with element
 */
type SpecElement<TDriver, TElement, TSelector> = {
    /**
     * - return true if the value is an element, false otherwise
     */
    isCompatible: (element: any) => boolean;
    /**
     * - return true if the value is a valid selector, false otherwise
     */
    isSelector: (selector: any) => boolean;
    /**
     * - translate cross SDK selector to SDK specific selector
     */
    toSupportedSelector: (selector: EyesSelector) => TSelector;
    /**
     * - translate SDK specific selector to cross SDK selector
     */
    toEyesSelector: (selector: TSelector) => EyesSelector;
    /**
     * - extract id from the unwrapped element
     */
    extractId: (element: EyesWrappedElement<TDriver, TElement, TSelector>) => Promise<string>;
    /**
     * - extract an element from the supported element
     */
    extractElement?: (element: TElement) => TElement;
    /**
     * - extract an element from the supported element
     */
    extractSelector?: (element: TElement) => TSelector;
    /**
     * - check if is a stale element reference result
     */
    isStaleElementReferenceResult?: (result: any) => boolean;
};
type EyesWrappedDriver<TDriver, TElement, TSelector> = import("./EyesWrappedDriver")<TDriver, TElement, TSelector>;
type Region = import("../geometry/Region");
type RectangleSize = import("../geometry/RectangleSize");
type Location = import("../geometry/Location");
type EyesWrappedElementCtor<TDriver, TElement, TSelector> = new (logger?: Logger, driver?: import("./EyesWrappedDriver")<TDriver, TElement, TSelector>, element?: TElement, selector?: TSelector) => EyesWrappedElement<TDriver, TElement, TSelector>;
type EyesWrappedElementStatics<TDriver, TElement, TSelector> = {
    fromElement: (element: TElement) => EyesWrappedElement<TDriver, TElement, TSelector>;
    fromSelector: (selector: TSelector) => EyesWrappedElement<TDriver, TElement, TSelector>;
    isCompatible: (element: any) => element is TElement;
    isSelector: (selector: any) => selector is TSelector;
    toSupportedSelector: (selector: EyesSelector) => TSelector;
    toEyesSelector: (selector: TSelector) => EyesSelector;
    extractId: (element: TElement | EyesWrappedElement<TDriver, TElement, TSelector>) => Promise<string>;
};
type Logger = import("../logging/Logger");
/**
 * Cross SDK selector
 */
type EyesSelector = {
    type: 'css' | 'xpath';
    selector: string;
};
