export type Logger = import("./logging/Logger");
export type EyesBrowsingContext = import("./wrappers/EyesBrowsingContext")<any, any, any>;
export type EyesDriverController = import("./wrappers/EyesDriverController")<any, any, any>;
export type EyesElementFinder = import("./wrappers/EyesElementFinder")<any, any, any>;
export type EyesJsExecutor = import("./wrappers/EyesJsExecutor")<any, any, any>;
export type EyesWrappedElement = import("./wrappers/EyesWrappedElement")<any, any, any>;
export type PositionProvider = import("./positioning/PositionProvider");
export type ContextInfo<TElement> = {
    /**
     * - is root context
     */
    isRoot: boolean;
    /**
     * - is cors context related to the parent
     */
    isCORS: boolean;
    /**
     * - context document element
     */
    document: TElement;
    /**
     * - xpath to the frame element related to the parent context
     *
     * Extract information about relations between current context and its parent
     */
    frameSelector: string;
};
/**
 * @typedef {import('./logging/Logger')} Logger
 * @typedef {import('./wrappers/EyesBrowsingContext')} EyesBrowsingContext
 * @typedef {import('./wrappers/EyesDriverController')} EyesDriverController
 * @typedef {import('./wrappers/EyesElementFinder')} EyesElementFinder
 * @typedef {import('./wrappers/EyesJsExecutor')} EyesJsExecutor
 * @typedef {import('./wrappers/EyesWrappedElement')} EyesWrappedElement
 * @typedef {import('./positioning/PositionProvider')} PositionProvider
 */
/**
 * Returns viewport size of current context
 * @param {Logger} _logger - logger instance
 * @param {Object} driver
 * @param {EyesJsExecutor} driver.executor - js executor
 * @return {RectangleSize} viewport size
 */
export function getViewportSize(_logger: Logger, { executor }: {
    executor: EyesJsExecutor;
}): import("./geometry/RectangleSize");
/**
 * Set viewport size of the window
 * @param {Logger} logger - logger instance
 * @param {Object} driver
 * @param {EyesDriverController} driver.controller - driver controller
 * @param {EyesJsExecutor} driver.executor - js executor
 * @param {EyesBrowsingContext} driver.context - browsing context
 * @param {RectangleSize} requiredViewportSize - required viewport size to set
 */
export function setViewportSize(logger: Logger, { controller, executor, context }: {
    controller: EyesDriverController;
    executor: EyesJsExecutor;
    context: EyesBrowsingContext;
}, requiredViewportSize: import("./geometry/RectangleSize")): Promise<any>;
/**
 * Get top-level context viewport region, where location of the region is top-level scroll position
 * @param {Logger} logger - logger instance
 * @param {Object} driver
 * @param {EyesDriverController} driver.controller - driver controller
 * @param {EyesJsExecutor} driver.executor - js executor
 * @param {EyesBrowsingContext} driver.context - browsing context
 * @return {Region} top-level context region
 */
export function getTopContextViewportRect(logger: Logger, { controller, executor, context }: {
    controller: EyesDriverController;
    executor: EyesJsExecutor;
    context: EyesBrowsingContext;
}): import("./geometry/Region");
/**
 * Get top-level context viewport size with fallback to the window size if fail to extract top-level context viewport size
 * @param {Logger} logger - logger instance
 * @param {Object} driver
 * @param {EyesDriverController} driver.controller - driver controller
 * @param {EyesJsExecutor} driver.executor - js executor
 * @param {EyesBrowsingContext} driver.context - browsing context
 * @return {Region} top-level context size
 */
export function getTopContextViewportSize(logger: Logger, { controller, context, executor }: {
    controller: EyesDriverController;
    executor: EyesJsExecutor;
    context: EyesBrowsingContext;
}): import("./geometry/Region");
/**
 * Get current context content size
 * @param {Logger} _logger - logger instance
 * @param {EyesJsExecutor} executor - js executor
 * @return {Region} current context content size
 */
export function getCurrentFrameContentEntireSize(_logger: Logger, executor: import("./wrappers/EyesJsExecutor")<any, any, any>): import("./geometry/Region");
/**
 * Get content size of the specified element
 * @param {Logger} _logger - logger instance
 * @param {EyesJsExecutor} executor - js executor
 * @param {EyesWrappedElement} element - element to get size
 * @returns {Promise<Region>} element content size
 */
export function getElementEntireSize(_logger: Logger, executor: import("./wrappers/EyesJsExecutor")<any, any, any>, element: import("./wrappers/EyesWrappedElement")<any, any, any>): Promise<import("./geometry/Region")>;
/**
 * Get element client rect relative to the current context
 * @param {Logger} _logger - logger instance
 * @param {EyesJsExecutor} executor - js executor
 * @param {EyesWrappedElement} element - element to get client rect
 * @return {Promise<Region>} element client rect
 */
export function getElementClientRect(_logger: Logger, executor: import("./wrappers/EyesJsExecutor")<any, any, any>, element: import("./wrappers/EyesWrappedElement")<any, any, any>): Promise<import("./geometry/Region")>;
/**
 * Get element rect relative to the current context
 * @param {Logger} _logger - logger instance
 * @param {EyesJsExecutor} executor - js executor
 * @param {EyesWrappedElement} element - element to get rect
 * @return {Promise<Region>} element rect
 */
export function getElementRect(_logger: Logger, executor: import("./wrappers/EyesJsExecutor")<any, any, any>, element: import("./wrappers/EyesWrappedElement")<any, any, any>): Promise<import("./geometry/Region")>;
/**
 * Extract values of specified properties for specified element
 * @param {Logger} _logger - logger instance
 * @param {EyesJsExecutor} executor - js executor
 * @param {string[]} properties - names of properties to extract
 * @param {EyesWrappedElement} element - element to extract properties
 * @return {*[]} extracted values
 */
export function getElementProperties(_logger: Logger, executor: import("./wrappers/EyesJsExecutor")<any, any, any>, properties: string[], element: import("./wrappers/EyesWrappedElement")<any, any, any>): any[];
/**
 * Extract css values of specified css properties for specified element
 * @param {Logger} _logger - logger instance
 * @param {EyesJsExecutor} executor - js executor
 * @param {string[]} properties - names of css properties to extract
 * @param {EyesWrappedElement} element - element to extract css properties
 * @return {string[]} extracted css values
 */
export function getElementCssProperties(_logger: Logger, executor: import("./wrappers/EyesJsExecutor")<any, any, any>, properties: string[], element: import("./wrappers/EyesWrappedElement")<any, any, any>): string[];
/**
 * Get device pixel ratio
 * @param {Logger} _logger - logger instance
 * @param {Object} driver
 * @param {EyesJsExecutor} driver.executor - js executor
 * @return {Promise<number>} device pixel ratio
 */
export function getDevicePixelRatio(_logger: Logger, { executor }: {
    executor: EyesJsExecutor;
}): Promise<number>;
/**
 * Get mobile device pixel ratio
 * @param {Logger} _logger - logger instance
 * @param {Object} driver
 * @param {EyesDriverController} driver.controller - driver controller
 * @return {Promise<number>} mobile device pixel ratio
 */
export function getMobilePixelRatio(_logger: Logger, { controller }: {
    controller: EyesDriverController;
}, viewportSize: any): Promise<number>;
export function getInnerOffsets(_logger: any, executor: any, element: any): Promise<import("./geometry/Location")>;
/**
 * Get top-level context scroll position
 * @param {Logger} logger - logger instance
 * @param {Object} driver
 * @param {EyesJsExecutor} driver.executor - js executor
 * @param {EyesBrowsingContext} driver.context - browsing context
 * @return {Promise<Location>} top-level context scroll position
 */
export function getTopContextScrollLocation(logger: Logger, { context, executor }: {
    executor: EyesJsExecutor;
    context: EyesBrowsingContext;
}): Promise<Location>;
/**
 * Get current context scroll position of the specified element or default scrolling element
 * @param {Logger} _logger - logger instance
 * @param {EyesJsExecutor} executor - js executor
 * @param {EyesWrappedElement} [element] - element to extract scroll position
 * @return {Promise<Location>} scroll position
 */
export function getScrollLocation(_logger: Logger, executor: import("./wrappers/EyesJsExecutor")<any, any, any>, element?: import("./wrappers/EyesWrappedElement")<any, any, any>): Promise<Location>;
/**
 * Set current context scroll position for the specified element or default scrolling element
 * @param {Logger} _logger - logger instance
 * @param {EyesJsExecutor} executor - js executor
 * @param {Location} location - required scroll position
 * @param {EyesWrappedElement} [element] - element to set scroll position
 * @return {Promise<Location>} actual scroll position after set
 */
export function scrollTo(_logger: Logger, executor: import("./wrappers/EyesJsExecutor")<any, any, any>, location: Location, element?: import("./wrappers/EyesWrappedElement")<any, any, any>): Promise<Location>;
/**
 * Get transforms of the specified element or default scrolling element
 * @param {Logger} _logger - logger instance
 * @param {EyesJsExecutor} executor - js executor
 * @param {EyesWrappedElement} [element] - element to extract transforms
 * @return {Promise<Object>} element transforms
 */
export function getTransforms(_logger: Logger, executor: import("./wrappers/EyesJsExecutor")<any, any, any>, element?: import("./wrappers/EyesWrappedElement")<any, any, any>): Promise<any>;
/**
 * Set transforms for the specified element or default scrolling element
 * @param {Logger} _logger - logger instance
 * @param {EyesJsExecutor} executor - js executor
 * @param {Object} transforms - collection of transforms to set
 * @param {EyesWrappedElement} [element] - element to set transforms
 */
export function setTransforms(_logger: Logger, executor: import("./wrappers/EyesJsExecutor")<any, any, any>, transforms: any, element?: import("./wrappers/EyesWrappedElement")<any, any, any>): Promise<any>;
/**
 * Get translate position of the specified element or default scrolling element
 * @param {Logger} _logger - logger instance
 * @param {EyesJsExecutor} executor - js executor
 * @param {EyesWrappedElement} [element] - element to extract translate position
 * @return {Promise<Location>} translate position
 */
export function getTranslateLocation(_logger: Logger, executor: import("./wrappers/EyesJsExecutor")<any, any, any>, element?: import("./wrappers/EyesWrappedElement")<any, any, any>): Promise<Location>;
/**
 * Set translate position of the specified element or default scrolling element
 * @param {Logger} _logger - logger instance
 * @param {EyesJsExecutor} executor - js executor
 * @param {Location} location - required translate position
 * @param {EyesWrappedElement} [element] - element to set translate position
 * @return {Promise<Location>} actual translate position after set
 */
export function translateTo(_logger: Logger, executor: import("./wrappers/EyesJsExecutor")<any, any, any>, location: Location, element?: import("./wrappers/EyesWrappedElement")<any, any, any>): Promise<Location>;
/**
 * Check if the specified element or default scrolling element is scrollable
 * @param {Logger} _logger - logger instance
 * @param {EyesJsExecutor} executor - js executor
 * @param {EyesWrappedElement} [element] - element to check
 * @return {Promise<boolean>} true if element is scrollable, false otherwise
 */
export function isScrollable(_logger: Logger, executor: import("./wrappers/EyesJsExecutor")<any, any, any>, element?: import("./wrappers/EyesWrappedElement")<any, any, any>): Promise<boolean>;
/**
 * Mark the specified element or default scrolling element with `data-applitools-scroll`
 * @param {Logger} _logger - logger instance
 * @param {EyesJsExecutor} executor - js executor
 * @param {EyesWrappedElement} [element] - element to mark
 */
export function markScrollRootElement(_logger: Logger, executor: import("./wrappers/EyesJsExecutor")<any, any, any>, element?: import("./wrappers/EyesWrappedElement")<any, any, any>): Promise<any>;
/**
 * Get overflow style property of the specified element
 * @param {Logger} _logger - logger instance
 * @param {EyesJsExecutor} executor - js executor
 * @param {EyesWrappedElement} element - element to get overflow
 * @return {Promise<string?>} overflow value
 */
export function getOverflow(_logger: Logger, executor: import("./wrappers/EyesJsExecutor")<any, any, any>, element: import("./wrappers/EyesWrappedElement")<any, any, any>): Promise<string | null>;
/**
 * Set overflow style property of the specified element
 * @param {Logger} _logger - logger instance
 * @param {EyesJsExecutor} executor - js executor
 * @param {EyesWrappedElement} element - element to set overflow
 * @return {Promise<string?>} original overflow value before set
 */
export function setOverflow(_logger: Logger, executor: import("./wrappers/EyesJsExecutor")<any, any, any>, overflow: any, element: import("./wrappers/EyesWrappedElement")<any, any, any>): Promise<string | null>;
/**
 * Blur the specified element or current active element
 * @template TElement
 * @param {Logger} logger - logger instance
 * @param {EyesJsExecutor} executor - js executor
 * @param {EyesWrappedElement} [element] - element to blur
 * @return {Promise<TElement>} actually blurred element if there is any
 */
export function blurElement<TElement>(logger: Logger, executor: import("./wrappers/EyesJsExecutor")<any, any, any>, element?: import("./wrappers/EyesWrappedElement")<any, any, any>): Promise<TElement>;
/**
 * Focus the specified element
 * @param {Logger} logger - logger instance
 * @param {EyesJsExecutor} executor - js executor
 * @param {EyesWrappedElement} element - element to focus
 */
export function focusElement(logger: Logger, executor: import("./wrappers/EyesJsExecutor")<any, any, any>, element: import("./wrappers/EyesWrappedElement")<any, any, any>): Promise<any>;
/**
 * Get element xpath selector related to the current context
 * @param {Logger} logger - logger instance
 * @param {EyesJsExecutor} executor - js executor
 * @param {EyesWrappedElement} element - element to calculate xpath
 * @return {Promise<string>} xpath selector
 */
export function getElementXpath(logger: Logger, executor: import("./wrappers/EyesJsExecutor")<any, any, any>, element: import("./wrappers/EyesWrappedElement")<any, any, any>): Promise<string>;
/**
 * Get element absolute xpath selector related to the top-level context
 * @param {Logger} _logger - logger instance
 * @param {EyesJsExecutor} executor - js executor
 * @param {EyesWrappedElement} element - element to calculate xpath
 * @return {Promise<string>} xpath selector
 */
export function getElementAbsoluteXpath(_logger: Logger, executor: import("./wrappers/EyesJsExecutor")<any, any, any>, element: import("./wrappers/EyesWrappedElement")<any, any, any>): Promise<string>;
/**
 * Translate element selector to the persisted regions
 * @template TSelector
 * @param {Logger} logger - logger instance
 * @param {Object} driver
 * @param {EyesElementFinder} driver.finder - element finder
 * @param {EyesJsExecutor} driver.executor - js executor
 * @param {TSelector} selector - element selector
 * @return {Promise<{type: string, selector: string}[]>} persisted regions for selector
 */
export function locatorToPersistedRegions<TSelector>(logger: Logger, { finder, executor }: {
    finder: EyesElementFinder;
    executor: EyesJsExecutor;
}, selector: TSelector): Promise<{
    type: string;
    selector: string;
}[]>;
/**
 * Ensure provided region is visible as much as possible
 * @param {Logger} logger - logger instance
 * @param {Object} driver
 * @param {EyesDriverController} driver.controller - driver controller
 * @param {EyesBrowsingContext} driver.context - browsing context
 * @param {EyesJsExecutor} driver.executor - js executor
 * @param {PositionProvider} positionProvider - position provider
 * @param {Promise<Region>} region - region to ensure visible
 */
export function ensureRegionVisible(logger: Logger, { controller, context, executor }: {
    controller: EyesDriverController;
    context: EyesBrowsingContext;
    executor: EyesJsExecutor;
}, positionProvider: PositionProvider, region: Promise<import("./geometry/Region")>): Promise<Location | import("./geometry/Location")>;
/**
 * Ensure provided region is visible as much as possible
 * @param {Logger} _logger - logger instance
 * @param {EyesBrowsingContext} context - browsing context
 * @param {PositionProvider} positionProvider - position provider
 * @param {Location} [offset=Location.ZERO] - offset from the top-left frame's corner
 * @return {Promise<Location>} remaining offset to the frame
 */
export function ensureFrameVisible(_logger: Logger, context: import("./wrappers/EyesBrowsingContext")<any, any, any>, positionProvider: PositionProvider, offset?: Location): Promise<Location>;
/**
 * @template TElement
 * @typedef ContextInfo
 * @prop {boolean} isRoot - is root context
 * @prop {boolean} isCORS - is cors context related to the parent
 * @prop {TElement} document - context document element
 * @prop {string} frameSelector - xpath to the frame element related to the parent context
 *
 * Extract information about relations between current context and its parent
 * @template TElement
 * @param {Logger} _logger - logger instance
 * @param {EyesJsExecutor} executor - js executor
 * @return {Promise<ContextInfo<TElement>>} frame info
 */
export function getCurrentContextInfo(_logger: Logger, executor: import("./wrappers/EyesJsExecutor")<any, any, any>): Promise<ContextInfo<any>>;
/**
 * Get frame element by name or id
 * @template TElement
 * @param {Logger} _logger - logger instance
 * @param {EyesJsExecutor} executor - js executor
 * @param {string} nameOrId - name or id of the element
 * @return {TElement} frame element
 */
export function getFrameByNameOrId<TElement>(_logger: Logger, executor: import("./wrappers/EyesJsExecutor")<any, any, any>, nameOrId: string): TElement;
/**
 * Find by context information
 * @template TElement
 * @param {Logger} _logger - logger instance
 * @param {Object} driver
 * @param {EyesBrowsingContext} driver.context - browsing context
 * @param {EyesJsExecutor} driver.executor - js executor
 * @param {ContextInfo} contextInfo - target context info
 * @param {(left: TElement, right: TElement) => Promise<boolean>} comparator - check if two document elements are equal
 * @return {Promise<Frame>} frame
 */
export function findFrameByContext<TElement>(_logger: Logger, { executor, context }: {
    context: EyesBrowsingContext;
    executor: EyesJsExecutor;
}, contextInfo: any, comparator: (left: TElement, right: TElement) => Promise<boolean>): Promise<any>;
declare const Location_1: typeof import("./geometry/Location");
export {};
