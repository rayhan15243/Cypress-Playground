export = Frame;
/**
 * @typedef {import('../logging/Logger')} Logger
 * @typedef {import('../geometry/Location')} Location
 * @typedef {import('../geometry/RectangleSize')} RectangleSize
 */
/**
 * @template TDriver, TElement, TSelector
 * @typedef {import('./EyesWrappedDriver')<TDriver, TElement, TSelector>} EyesWrappedDriver
 */
/**
 * @template TDriver, TElement, TSelector
 * @typedef {import('../wrappers/EyesWrappedElement')<TDriver, TElement, TSelector>} EyesWrappedElement
 */
/**
 * Reference to the frame, index of the frame in the current context, name or id of the element,
 * framework element object, {@link EyesWrappedElement} implementation object
 * @template TDriver, TElement, TSelector
 * @typedef {Frame<TDriver, TElement, TSelector>|EyesWrappedElement<TDriver, TElement, TSelector>|TElement|TSelector|number|string} FrameReference
 */
/**
 * @template TDriver, TElement, TSelector
 * @typedef SpecFrame
 * @prop {(selector) => boolean} isSelector - return true if the value is a valid selector, false otherwise
 * @prop {(element) => boolean} isCompatibleElement - return true if the value is an element, false otherwise
 * @prop {(logger: Logger, driver: EyesWrappedDriver<TDriver, TElement, TSelector>, element: TElement, selector: TSelector) => EyesWrappedElement<TDriver, TElement, TSelector>} createElement - return wrapped element instance
 * @prop {(leftElement: EyesWrappedElement<TDriver, TElement, TSelector>|TElement, rightElement: EyesWrappedElement<TDriver, TElement, TSelector>|TElement) => Promise<boolean>} isEqualElements - return true if elements are equal, false otherwise
 */
/**
 * @template TDriver, TElement, TSelector
 * @typedef {new (logger: Logger, driver: EyesWrappedDriver<TDriver, TElement, TSelector>, frame) => Frame<TDriver, TElement, TSelector>} FrameCtor
 */
/**
 * @template TDriver, TElement, TSelector
 * @typedef FrameStatics
 * @prop {(reference: FrameReference<TDriver, TElement, TSelector>, scrollRootElement?: EyesWrappedElement<TDriver, TElement, TSelector>) => Frame<TDriver, TElement, TSelector>} fromReference
 * @prop {(reference) => reference is FrameReference<TDriver, TElement, TSelector>} isReference
 */
/**
 * Encapsulates a frame/iframe. This is a generic type class,
 * and it's actual type is determined by the element used by the user in
 * order to switch into the frame.
 * @template TDriver - TDriver provided by wrapped framework
 * @template TElement - TElement provided by wrapped framework
 * @template TSelector - TSelector supported by framework
 */
declare class Frame<TDriver, TElement, TSelector> {
    /**
     * @template TDriver, TElement, TSelector
     * @param {SpecFrame<TDriver, TElement, TSelector>} spec
     * @return {FrameCtor<TDriver, TElement, TSelector> & FrameStatics<TDriver, TElement, TSelector>}
     */
    static specialize<TDriver_1, TElement_1, TSelector_1>(spec: SpecFrame<TDriver_1, TElement_1, TSelector_1>): (new (logger: Logger, driver: any, frame: any) => import("./Frame")<TDriver_1, TElement_1, TSelector_1>) & FrameStatics<TDriver_1, TElement_1, TSelector_1>;
    /** @type {SpecFrame<E,S>} */
    static get spec(): any;
    /**
     * Construct frame reference object which could be later initialized to the full frame object
     * @template TDriver, TElement, TSelector
     * @param {FrameReference<TDriver, TElement, TSelector>} reference - reference to the frame on its parent context
     * @param {EyesWrappedElement<TDriver, TElement, TSelector>} [scrollRootElement] - scroll root element
     * @return {Frame<TDriver, TElement, TSelector>} frame reference object
     */
    static fromReference<TDriver_3, TElement_3, TSelector_3>(reference: string | number | TElement_3 | TSelector_3 | import("./Frame")<TDriver_3, TElement_3, TSelector_3> | import("../wrappers/EyesWrappedElement")<TDriver_3, TElement_3, TSelector_3>, scrollRootElement?: import("../wrappers/EyesWrappedElement")<TDriver_3, TElement_3, TSelector_3>): Frame<TDriver_3, TElement_3, TSelector_3>;
    /**
     * Check value for belonging to the {@link FrameReference} type
     * @template TDriver, TElement, TSelector
     * @param reference - value to check if is it a reference
     * @return {reference is FrameReference<TDriver, TElement, TSelector>} true if value is a valid reference, otherwise false
     */
    static isReference<TDriver_4, TElement_4, TSelector_4>(reference: any): reference is string | number | TElement_4 | TSelector_4 | import("./Frame")<TDriver_4, TElement_4, TSelector_4> | import("../wrappers/EyesWrappedElement")<TDriver_4, TElement_4, TSelector_4>;
    /**
     * Equality check for two frame objects or frame elements
     * @template TDriver, TElement, TSelector
     * @param {Frame<TDriver, TElement, TSelector>|EyesWrappedElement<TDriver, TElement, TSelector>} leftFrame - frame object or frame element
     * @param {Frame<TDriver, TElement, TSelector>|EyesWrappedElement<TDriver, TElement, TSelector>} rightFrame - frame object or frame element
     * @return {Promise<boolean>} true if frames are described the same frame element, otherwise false
     */
    static equals<TDriver_5, TElement_5, TSelector_5>(leftFrame: Frame<TDriver_5, TElement_5, TSelector_5> | import("../wrappers/EyesWrappedElement")<TDriver_5, TElement_5, TSelector_5>, rightFrame: Frame<TDriver_5, TElement_5, TSelector_5> | import("../wrappers/EyesWrappedElement")<TDriver_5, TElement_5, TSelector_5>): Promise<boolean>;
    /**
     * Create frame from components
     * @param {Logger} logger - logger instance
     * @param {EyesWrappedDriver<TDriver, TElement, TSelector>} driver - wrapped driver
     * @param {object} frame - frame components
     * @param {EyesWrappedElement<TDriver, TElement, TSelector>} frame.element - frame element, used as a element to switch into the frame
     * @param {Location} frame.location - location of the frame within the current frame
     * @param {RectangleSize} frame.size - frame element size (i.e., the size of the frame on the screen, not the internal document size)
     * @param {RectangleSize} frame.innerSize - frame element inner size (i.e., the size of the frame actual size, without borders)
     * @param {Location} frame.parentScrollLocation - scroll location of the frame
     * @param {EyesWrappedElement<TDriver, TElement, TSelector>} [frame.scrollRootElement] - scroll root element
     */
    constructor(logger: Logger, driver: any, frame: {
        element: import("../wrappers/EyesWrappedElement")<TDriver, TElement, TSelector>;
        location: Location;
        size: RectangleSize;
        innerSize: RectangleSize;
        parentScrollLocation: Location;
        scrollRootElement?: import("../wrappers/EyesWrappedElement")<TDriver, TElement, TSelector>;
    });
    /** @type {SpecFrame<E,S>} */
    get spec(): any;
    _reference: {
        element: import("../wrappers/EyesWrappedElement")<TDriver, TElement, TSelector>;
        location: Location;
        size: RectangleSize;
        innerSize: RectangleSize;
        parentScrollLocation: Location;
        scrollRootElement?: import("../wrappers/EyesWrappedElement")<TDriver, TElement, TSelector>;
    };
    _element: import("../wrappers/EyesWrappedElement")<TDriver, TElement, TSelector>;
    _location: import("../geometry/Location");
    _size: import("../geometry/RectangleSize");
    _innerSize: import("../geometry/RectangleSize");
    _parentScrollLocation: import("../geometry/Location");
    _scrollRootElement: import("../wrappers/EyesWrappedElement")<TDriver, TElement, TSelector>;
    _driver: any;
    _logger: import("../logging/Logger");
    /**
     * @return {EyesWrappedElement<TDriver, TElement, TSelector>}
     */
    get element(): import("../wrappers/EyesWrappedElement")<TDriver, TElement, TSelector>;
    /**
     * @return {Location}
     */
    get location(): import("../geometry/Location");
    /**
     * @return {RectangleSize}
     */
    get size(): import("../geometry/RectangleSize");
    /**
     * @return {RectangleSize}
     */
    get innerSize(): import("../geometry/RectangleSize");
    /**
     * @return {Location}
     */
    get parentScrollLocation(): import("../geometry/Location");
    /**
     * @param {EyesWrappedElement<TDriver, TElement, TSelector>} scrollRootElement
     */
    set scrollRootElement(arg: import("../wrappers/EyesWrappedElement")<TDriver, TElement, TSelector>);
    /**
     * @return {EyesWrappedElement<TDriver, TElement, TSelector>}
     */
    get scrollRootElement(): import("../wrappers/EyesWrappedElement")<TDriver, TElement, TSelector>;
    /**
     * Create reference from current frame object
     * @return {Frame<TDriver, TElement, TSelector>} frame reference object
     */
    toReference(): Frame<TDriver, TElement, TSelector>;
    /**
     * Equality check for two frame objects or frame elements
     * @param {Frame<TDriver, TElement, TSelector>|EyesWrappedElement<TDriver, TElement, TSelector>} otherFrame - frame object or frame element
     * @return {Promise<boolean>} true if frames are described the same frame element, otherwise false
     */
    equals(otherFrame: import("../wrappers/EyesWrappedElement")<TDriver, TElement, TSelector> | Frame<TDriver, TElement, TSelector>): Promise<boolean>;
    /**
     * Initialize frame reference by finding frame element and calculate metrics
     * @param {Logger} logger - logger instance
     * @param {EyesWrappedDriver<TDriver, TElement, TSelector>} driver - wrapped driver targeted on parent context
     * @return {this} initialized frame object
     */
    init(logger: Logger, driver: any, parentFrame: any): this;
    /**
     * Recalculate frame object metrics. TDriver should be targeted on a parent context
     * @return {this} this frame object
     */
    refresh(parentFrame: any): this;
    /**
     * @return {Promise<void>}
     */
    hideScrollbars(): Promise<void>;
    /**
     * @return {Promise<void>}
     */
    restoreScrollbars(): Promise<void>;
    /**
     * @param {PositionProvider} positionProvider
     * @return {Promise<void>}
     */
    preservePosition(positionProvider: any): Promise<void>;
    /**
     * @param {PositionProvider} positionProvider
     * @return {Promise<void>}
     */
    restorePosition(positionProvider: any): Promise<void>;
}
declare namespace Frame {
    export { Logger, Location, RectangleSize, EyesWrappedDriver, EyesWrappedElement, FrameReference, SpecFrame, FrameCtor, FrameStatics };
}
type EyesWrappedElement<TDriver, TElement, TSelector> = import("../wrappers/EyesWrappedElement")<TDriver, TElement, TSelector>;
declare const Location: typeof import("../geometry/Location");
declare const RectangleSize: typeof import("../geometry/RectangleSize");
type Logger = import("../logging/Logger");
type SpecFrame<TDriver, TElement, TSelector> = {
    /**
     * - return true if the value is a valid selector, false otherwise
     */
    isSelector: (selector: any) => boolean;
    /**
     * - return true if the value is an element, false otherwise
     */
    isCompatibleElement: (element: any) => boolean;
    /**
     * - return wrapped element instance
     */
    createElement: (logger: Logger, driver: any, element: TElement, selector: TSelector) => import("../wrappers/EyesWrappedElement")<TDriver, TElement, TSelector>;
    /**
     * - return true if elements are equal, false otherwise
     */
    isEqualElements: (leftElement: TElement | import("../wrappers/EyesWrappedElement")<TDriver, TElement, TSelector>, rightElement: TElement | import("../wrappers/EyesWrappedElement")<TDriver, TElement, TSelector>) => Promise<boolean>;
};
type FrameCtor<TDriver, TElement, TSelector> = new (logger: Logger, driver: any, frame: any) => import("./Frame")<TDriver, TElement, TSelector>;
type FrameStatics<TDriver, TElement, TSelector> = {
    fromReference: (reference: string | number | TElement | TSelector | import("./Frame")<TDriver, TElement, TSelector> | import("../wrappers/EyesWrappedElement")<TDriver, TElement, TSelector>, scrollRootElement?: import("../wrappers/EyesWrappedElement")<TDriver, TElement, TSelector>) => import("./Frame")<TDriver, TElement, TSelector>;
    isReference: (reference: any) => reference is string | number | TElement | TSelector | import("./Frame")<TDriver, TElement, TSelector> | import("../wrappers/EyesWrappedElement")<TDriver, TElement, TSelector>;
};
/**
 * Reference to the frame, index of the frame in the current context, name or id of the element,
 * framework element object, {@link EyesWrappedElement} implementation object
 */
type FrameReference<TDriver, TElement, TSelector> = string | number | TElement | TSelector | import("./Frame")<TDriver, TElement, TSelector> | import("../wrappers/EyesWrappedElement")<TDriver, TElement, TSelector>;
type Location = import("../geometry/Location");
type RectangleSize = import("../geometry/RectangleSize");
type EyesWrappedDriver<TDriver, TElement, TSelector> = any;
