export = EyesCore;
declare const EyesCore_base: typeof import("./EyesBase");
/**
 * @template TDriver, TElement, TSelector
 * @typedef {import('./wrappers/EyesWrappedDriver')<TDriver, TElement, TSelector>} EyesWrappedDriver
 */
/**
 * @template TDriver, TElement, TSelector
 * @typedef {import('./wrappers/EyesWrappedElement')<TDriver, TElement, TSelector>} EyesWrappedElement
 */
/**
 * @template TDriver, TElement, TSelector
 * @typedef {import('./frames/Frame').FrameReference<TDriver, TElement, TSelector>} FrameReference
 */
/**
 * @template TDriver
 * @template TElement
 * @template TSelector
 */
declare class EyesCore<TDriver, TElement, TSelector> extends EyesCore_base {
    static setViewportSize(driver: any, viewportSize: any): Promise<void>;
    constructor(serverUrl?: string, isDisabled?: boolean, configuration?: import("./config/Configuration"));
    /**
     * Takes a snapshot of the application under test and matches it with the expected output.
     * @param {string} [tag] - An optional tag to be associated with the snapshot.
     * @param {number} [matchTimeout] - The amount of time to retry matching (Milliseconds).
     * @param {boolean} [stitchContent=false] - If {@code true}, stitch the internal content of the window.
     * @return {Promise<MatchResult>} - A promise which is resolved when the validation is finished.
     */
    checkWindow(tag?: string, matchTimeout?: number, stitchContent?: boolean): Promise<any>;
    /**
     * Matches the frame given as parameter, by switching into the frame and using stitching to get an image of the frame.
     * @param {FrameReference<TDriver, TElement, TSelector>} element - The element which is the frame to switch to.
     * @param {number} [matchTimeout] - The amount of time to retry matching (milliseconds).
     * @param {string} [tag] - An optional tag to be associated with the match.
     * @return {Promise<MatchResult>} - A promise which is resolved when the validation is finished.
     */
    checkFrame(element: string | number | TElement | TSelector | import("./frames/Frame")<TDriver, TElement, TSelector> | import("./wrappers/EyesWrappedElement")<TDriver, TElement, TSelector>, matchTimeout?: number, tag?: string): Promise<any>;
    /**
     * Takes a snapshot of the application under test and matches a specific element with the expected region output.
     * @param {EyesWrappedElement<TDriver, TElement, TSelector>|TElement} element - The element to check.
     * @param {number} [matchTimeout] - The amount of time to retry matching (milliseconds).
     * @param {string} [tag] - An optional tag to be associated with the match.
     * @return {Promise<MatchResult>} - A promise which is resolved when the validation is finished.
     */
    checkElement(element: TElement | import("./wrappers/EyesWrappedElement")<TDriver, TElement, TSelector>, matchTimeout?: number, tag?: string): Promise<any>;
    /**
     * Takes a snapshot of the application under test and matches a specific element with the expected region output.
     * @param {TSelector} locator - The element to check.
     * @param {number} [matchTimeout] - The amount of time to retry matching (milliseconds).
     * @param {string} [tag] - An optional tag to be associated with the match.
     * @return {Promise<MatchResult>} - A promise which is resolved when the validation is finished.
     */
    checkElementBy(locator: TSelector, matchTimeout?: number, tag?: string): Promise<any>;
    /**
     * Visually validates a region in the screenshot.
     * @param {Region} region - The region to validate (in screenshot coordinates).
     * @param {string} [tag] - An optional tag to be associated with the screenshot.
     * @param {number} [matchTimeout] - The amount of time to retry matching.
     * @return {Promise<MatchResult>} - A promise which is resolved when the validation is finished.
     */
    checkRegion(region: import("./geometry/Region"), tag?: string, matchTimeout?: number): Promise<any>;
    /**
     * Visually validates a region in the screenshot.
     *
     * @param {EyesWrappedElement<TDriver, TElement, TSelector>|TElement} element - The element defining the region to validate.
     * @param {string} [tag] - An optional tag to be associated with the screenshot.
     * @param {number} [matchTimeout] - The amount of time to retry matching.
     * @return {Promise<MatchResult>} - A promise which is resolved when the validation is finished.
     */
    checkRegionByElement(element: TElement | import("./wrappers/EyesWrappedElement")<TDriver, TElement, TSelector>, tag?: string, matchTimeout?: number): Promise<any>;
    /**
     * Visually validates a region in the screenshot.
     *
     * @param {TSelector} by - The selector used for finding the region to validate.
     * @param {string} [tag] - An optional tag to be associated with the screenshot.
     * @param {number} [matchTimeout] - The amount of time to retry matching.
     * @param {boolean} [stitchContent] - If {@code true}, stitch the internal content of the region (i.e., perform
     *   {@link #checkElement(By, number, string)} on the region.
     * @return {Promise<MatchResult>} - A promise which is resolved when the validation is finished.
     */
    checkRegionBy(by: TSelector, tag?: string, matchTimeout?: number, stitchContent?: boolean): Promise<any>;
    /**
     * Switches into the given frame, takes a snapshot of the application under test and matches a region specified by
     * the given selector.
     * @param {FrameReference<TDriver, TElement, TSelector>} frameReference - The name or id of the frame to switch to.
     * @param {TSelector} locator - A TSelector specifying the region to check.
     * @param {?number} [matchTimeout] - The amount of time to retry matching. (Milliseconds)
     * @param {string} [tag] - An optional tag to be associated with the snapshot.
     * @param {boolean} [stitchContent] - If {@code true}, stitch the internal content of the region (i.e., perform
     *   {@link #checkElement(By, number, string)} on the region.
     * @return {Promise<MatchResult>} - A promise which is resolved when the validation is finished.
     */
    checkRegionInFrame(frameReference: string | number | TElement | TSelector | import("./frames/Frame")<TDriver, TElement, TSelector> | import("./wrappers/EyesWrappedElement")<TDriver, TElement, TSelector>, locator: TSelector, matchTimeout?: number | null, tag?: string, stitchContent?: boolean): Promise<any>;
    /**
     * @return {Promise}
     */
    closeAsync(): Promise<any>;
    /**
     * @return {Promise}
     */
    abortAsync(): Promise<any>;
    /**
     * Adds a mouse trigger.
     * @param {MouseTrigger.MouseAction} action  Mouse action.
     * @param {Region} control The control on which the trigger is activated (context relative coordinates).
     * @param {Location} cursor  The cursor's position relative to the control.
     */
    addMouseTrigger(action: any, control: import("./geometry/Region"), cursor: Location): Promise<void>;
    /**
     * Adds a mouse trigger.
     * @param {MouseTrigger.MouseAction} action  Mouse action.
     * @param {EyesWrappedElement<TDriver, TElement, TSelector>} element The element on which the click was called.
     * @return {Promise}
     */
    addMouseTriggerForElement(action: any, element: import("./wrappers/EyesWrappedElement")<TDriver, TElement, TSelector>): Promise<any>;
    /**
     * Adds a keyboard trigger.
     * @param {Region} control The control on which the trigger is activated (context relative coordinates).
     * @param {String} text  The trigger's text.
     */
    addTextTrigger(control: import("./geometry/Region"), text: string): Promise<void>;
    /**
     * Adds a keyboard trigger.
     * @param {EyesWrappedElement<TDriver, TElement, TSelector>} element The element for which we sent keys.
     * @param {String} text  The trigger's text.
     * @return {Promise}
     */
    addTextTriggerForElement(element: import("./wrappers/EyesWrappedElement")<TDriver, TElement, TSelector>, text: string): Promise<any>;
    _effectiveViewport: import("./geometry/Region");
    _dontGetTitle: boolean;
    /**
     * @return {EyesWrappedDriver<TDriver, TElement, TSelector>}
     */
    getDriver(): import("./wrappers/EyesWrappedDriver")<TDriver, TElement, TSelector>;
    /**
     * @return {TDriver}
     */
    getRemoteWebDriver(): TDriver;
    /**
     * Get jsExecutor
     * @return {EyesJsExecutor<TDriver, TElement, TSelector>}
     */
    get jsExecutor(): any;
    /**
     * @return {EyesRunner}
     */
    getRunner(): any;
    /**
     * @return {number} The device pixel ratio, or {@link #UNKNOWN_DEVICE_PIXEL_RATIO} if the DPR is not known yet or if it wasn't possible to extract it.
     */
    getDevicePixelRatio(): number;
    /**
     * @return {Region}
     */
    getRegionToCheck(): import("./geometry/Region");
    /**
     * @param {Region} regionToCheck
     */
    setRegionToCheck(regionToCheck: import("./geometry/Region")): void;
    _regionToCheck: import("./geometry/Region");
    /**
     * @return {boolean}
     */
    shouldStitchContent(): boolean;
    /**
     * @param {EyesWrappedElement<TDriver, TElement, TSelector>|TElement|TSelector} element
     */
    setScrollRootElement(scrollRootElement: any): void;
    _scrollRootElement: any;
    /**
     * @return {Promise<EyesWrappedElement<TDriver, TElement, TSelector>|TElement|TSelector>}
     */
    getScrollRootElement(): Promise<TElement | TSelector | import("./wrappers/EyesWrappedElement")<TDriver, TElement, TSelector>>;
    /**
     * @param {ImageRotation} rotation - The image rotation data.
     */
    setRotation(rotation: import("./positioning/ImageRotation")): void;
    _rotation: import("./positioning/ImageRotation");
    /**
     * @return {ImageRotation} - The image rotation data.
     */
    getRotation(): import("./positioning/ImageRotation");
    /**
     * Set the image rotation degrees.
     * @param {number} degrees - The amount of degrees to set the rotation to.
     * @deprecated use {@link setRotation} instead
     */
    setForcedImageRotation(degrees: number): void;
    /**
     * Get the rotation degrees.
     * @return {number} - The rotation degrees.
     * @deprecated use {@link getRotation} instead
     */
    getForcedImageRotation(): number;
    /**
     * @param {string} domUrl
     */
    setDomUrl(domUrl: string): void;
    _domUrl: string;
    /**
     * @param {CorsIframeHandle} corsIframeHandle
     */
    setCorsIframeHandle(corsIframeHandle: any): void;
    _corsIframeHandle: any;
    /**
     * @return {CorsIframeHandle}
     */
    getCorsIframeHandle(): any;
    /**
     * @return {boolean}
     */
    getHideCaret(): boolean;
    /**
     * @param {boolean} hideCaret
     */
    setHideCaret(hideCaret: boolean): void;
    /**
     * Forces a full page screenshot (by scrolling and stitching) if the browser only supports viewport screenshots).
     *
     * @param {boolean} shouldForce - Whether to force a full page screenshot or not.
     */
    setForceFullPageScreenshot(shouldForce: boolean): void;
    /**
     * @return {boolean} - Whether Eyes should force a full page screenshot.
     */
    getForceFullPageScreenshot(): boolean;
    /**
     * Sets the time to wait just before taking a screenshot (e.g., to allow positioning to stabilize when performing a
     * full page stitching).
     *
     * @param {number} waitBeforeScreenshots - The time to wait (Milliseconds). Values smaller or equal to 0, will cause the
     *   default value to be used.
     */
    setWaitBeforeScreenshots(waitBeforeScreenshots: number): void;
    /**
     * @return {number} - The time to wait just before taking a screenshot.
     */
    getWaitBeforeScreenshots(): number;
    /**
     * Hide the scrollbars when taking screenshots.
     *
     * @param {boolean} shouldHide - Whether to hide the scrollbars or not.
     */
    setHideScrollbars(shouldHide: boolean): void;
    /**
     * @return {boolean} - Whether or not scrollbars are hidden when taking screenshots.
     */
    getHideScrollbars(): boolean;
    /**
     * Set the type of stitching used for full page screenshots. When the page includes fixed position header/sidebar,
     * use {@link StitchMode#CSS}. Default is {@link StitchMode#SCROLL}.
     *
     * @param {StitchMode} mode - The stitch mode to set.
     */
    setStitchMode(mode: any): void;
    /**
     * @return {StitchMode} - The current stitch mode settings.
     */
    getStitchMode(): any;
    /**
     * Sets the stitching overlap in pixels.
     *
     * @param {number} stitchOverlap - The width (in pixels) of the overlap.
     */
    setStitchOverlap(stitchOverlap: number): void;
    /**
     * @return {number} - Returns the stitching overlap in pixels.
     */
    getStitchOverlap(): number;
}
declare namespace EyesCore {
    export { EyesWrappedDriver, EyesWrappedElement, FrameReference };
}
type FrameReference<TDriver, TElement, TSelector> = string | number | TElement | TSelector | import("./frames/Frame")<TDriver, TElement, TSelector> | import("./wrappers/EyesWrappedElement")<TDriver, TElement, TSelector>;
type EyesWrappedElement<TDriver, TElement, TSelector> = import("./wrappers/EyesWrappedElement")<TDriver, TElement, TSelector>;
declare const Location: typeof import("./geometry/Location");
type EyesWrappedDriver<TDriver, TElement, TSelector> = import("./wrappers/EyesWrappedDriver")<TDriver, TElement, TSelector>;
