/// <reference types="node" />
/**
 * Concatenate the url to the suffixes - making sure there are no double slashes
 *
 * @param {string} url - The left side of the URL.
 * @param {...string} suffixes - The right side.
 * @return {string} - the URL
 */
export function urlConcat(url: string, ...suffixes: string[]): string;
/**
 * If given URL ends with '/', the method with cut it and return URL without it
 *
 * @param {string} url
 * @return {string}
 */
export function stripTrailingSlash(url: string): string;
/**
 * Check if an URL is absolute
 *
 * @param {string} url
 * @return {boolean} - the URL
 */
export function isAbsoluteUrl(url: string): boolean;
/**
 * Converts all arguments to a single string, used for logging
 *
 * @param {...*} args
 * @return {string}
 */
export function stringify(...args: any[]): string;
/**
 * Converts argument to string
 *
 * @param {*} arg
 * @return {string}
 */
export function stringifySingle(arg: any): string;
/**
 * Converts object or class to string, used within `toString` method of classes
 *
 * @param {object} object
 * @param {string[]} [exclude]
 * @return {string}
 */
export function toString(object: object, exclude?: string[]): string;
/**
 * Convert a class to plain object
 * Makes all private properties public (remove '_' char from prop names)
 *
 * @param {object} object
 * @param {string[]} [exclude]
 * @param {object} [rename]
 * @return {object}
 */
export function toPlain(object: object, exclude?: string[], rename?: object): object;
/**
 * Merge two objects x and y deeply, returning a new merged object with the elements from both x and y.
 * If an element at the same key is present for both x and y, the value from y will appear in the result.
 * Merging creates a new object, so that neither x or y are be modified.
 * @see package 'deepmerge'
 *
 * @template TFirst
 * @template TSecond
 * @param {TFirst} target
 * @param {TSecond} source
 * @return {TFirst|TSecond}
 */
export function mergeDeep<TFirst, TSecond>(target: TFirst, source: TSecond): TFirst | TSecond;
/**
 * Generate GUID
 *
 * @return {string}
 */
export function guid(): string;
/**
 * Generate random alphanumeric sequence
 *
 * @return {string}
 */
export function randomAlphanumeric(length?: number): string;
/**
 * Waits a specified amount of time before resolving the returned promise.
 *
 * @param {number} ms - The amount of time to sleep in milliseconds.
 * @return {Promise} - A promise which is resolved when sleep is done.
 */
export function sleep(ms: number): Promise<any>;
/**
 * Convert a Date object to a ISO-8601 date string
 *
 * @deprecated Use {@link DateTimeUtils.toISO8601DateTime} instead
 * @param {Date} [date] - Date which will be converted
 * @return {string} - string formatted as ISO-8601 (yyyy-MM-dd'T'HH:mm:ss'Z')
 */
export function toISO8601DateTime(date?: Date): string;
/**
 * Convert a Date object to a RFC-1123 date string
 *
 * @deprecated Use {@link DateTimeUtils.toRfc1123DateTime} instead
 * @param {Date} [date] - Date which will be converted
 * @return {string} - string formatted as RFC-1123 (E, dd MMM yyyy HH:mm:ss 'GMT')
 */
export function toRfc1123DateTime(date?: Date): string;
/**
 * @deprecated Use {@link DateTimeUtils.toLogFileDateTime} instead
 * @param {Date} [date] - Date which will be converted
 * @return {string} - string formatted as RFC-1123 (yyyy_mm_dd__HH_MM_ss_l)
 */
export function toLogFileDateTime(date?: Date): string;
/**
 * Creates {@link Date} instance from an ISO 8601 formatted string.
 *
 * @deprecated Use {@link DateTimeUtils.fromISO8601DateTime} instead
 * @param {string} dateTime - An ISO 8601 formatted string.
 * @return {Date} - A {@link Date} instance representing the given date and time.
 */
export function fromISO8601DateTime(dateTime: string): Date;
/**
 * Simple method that decode JSON Web Tokens
 *
 * @param {string} token
 * @return {object}
 */
export function jwtDecode(token: string): object;
/**
 * Cartesian product of arrays
 *
 * @param {...([]|Object)} arrays - Variable number of arrays of n elements
 * @return {Array<Array<[]>>} - Product of arrays as an array of X arrays of N elements,
 *   where X is the product of the input arrays' lengths
 */
export function cartesianProduct(...arrays: ([] | any)[]): Array<Array<[]>>;
/**
 * Get a property of the object by a path string
 *
 * @param {object} object - The object to query.
 * @param {string} path - The path of a property (example: "foo.bar.baz" ).
 * @return {*|undefined} - The value of the given property or `undefined` if the property is not exists.
 */
export function getPropertyByPath(object: object, path: string): any | undefined;
/**
 * Get an environment property by property name
 *
 * @param {string} propName The property name to look up
 * @param {boolean=false} isBoolean Whether or not the value should be converted to boolean type
 * @return {*|undefined} - The value of the given property or `undefined` if the property is not exists.
 */
export function getEnvValue(propName: string, isBoolean?: boolean): any | undefined;
/**
 * Make sure new param value is set with either backward compatible param or the new param.
 *
 * @param {...object[]} params The parameter map.
 * @param {logger} logger to log errors
 * @example
 *
 * foo({newParam, oldPram}) {
 *    ({newParam} = backwardCompatible([{oldParam}, {newParam}], logger))
 *    // now if oldParam is used we set it to oldParam and log a deprecation message.
 * }
 *
 */
export function backwardCompatible(...args: any[]): {};
/**
 * @param {string} str
 * @return {string}
 */
export function cleanStringForJSON(str: string): string;
export function isFeatureFlagOn(featureName: any): boolean;
export function isFeatureFlagOff(featureName: any): boolean;
/**
 * @template T
 * @param {PromiseLike<T>} promise
 *
 * @returns {PromiseLike<[any|undefined, T|undefined]>} a 2-tuple where the first element is the error if promise is rejected,
 *   or undefined if resolved,
 *   and the second value is the value resolved by the promise, or undefined if rejected
 *
 * Note: copyied @applitools/functional-commons
 */
export function presult<T>(promise: PromiseLike<T>): PromiseLike<[any, T]>;
export function pexec(...args: any[]): import("child_process").PromiseWithChild<{
    stdout: string;
    stderr: string;
}> & import("child_process").PromiseWithChild<{
    stdout: Buffer;
    stderr: Buffer;
}> & import("child_process").PromiseWithChild<{
    stdout: string;
    stderr: string;
}> & import("child_process").PromiseWithChild<{
    stdout: string;
    stderr: string;
}> & import("child_process").PromiseWithChild<{
    stdout: string | Buffer;
    stderr: string | Buffer;
}>;
export function cachify(getterFunction: any, cacheRegardlessOfArgs?: boolean): (...args: any[]) => any;
