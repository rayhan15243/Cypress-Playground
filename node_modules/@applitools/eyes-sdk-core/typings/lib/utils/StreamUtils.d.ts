/// <reference types="node" />
declare const _exports: {
    ReadableBufferStream: unknown;
    WritableBufferStream: unknown;
};
export = _exports;
declare const ReadableBufferStream_base: typeof import("stream").Readable;
declare class ReadableBufferStream extends ReadableBufferStream_base {
    /**
     * @param {Buffer} buffer - The buffer to be used as the stream's source.
     * @param {object} [options] - An "options" object to be passed to the stream constructor.
     */
    constructor(buffer: Buffer, options?: object);
    _buffer: Buffer;
}
declare const WritableBufferStream_base: typeof import("stream").Writable;
declare class WritableBufferStream extends WritableBufferStream_base {
    /**
     * @param {object} [options] - An "options" object to be passed to the stream constructor.
     * @return {WritableBufferStream}
     */
    constructor(options?: object);
    _buffer: Buffer;
    /**
     * @return {boolean} {@code false} if the stream wishes for the calling code to wait for the 'drain' event to be
     *   emitted before continuing to write additional data, otherwise {@code true}.
     */
    writeInt(value: any): boolean;
    /**
     * @return {boolean} {@code false} if the stream wishes for the calling code to wait for the 'drain' event to be
     *   emitted before continuing to write additional data, otherwise {@code true}.
     */
    writeShort(value: any): boolean;
    /**
     * @return {boolean} {@code false} if the stream wishes for the calling code to wait for the 'drain' event to be
     *   emitted before continuing to write additional data, otherwise {@code true}.
     */
    writeByte(value: any): boolean;
    /**
     * @return {Buffer} - The buffer which contains the chunks written up to this point.
     */
    getBuffer(): Buffer;
    /**
     * Resets the buffer which contains the chunks written so far.
     * @return {Buffer} - The buffer which contains the chunks written up to the reset.
     */
    resetBuffer(): Buffer;
}
