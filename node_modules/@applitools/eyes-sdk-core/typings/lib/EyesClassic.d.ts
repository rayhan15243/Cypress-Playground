export = EyesClassic;
declare const EyesClassic_base: typeof import("./EyesCore");
/**
 * @template TDriver
 * @template TElement
 * @template TSelector
 * @extends {EyesCore<TDriver, TElement, TSelector>}
 */
declare class EyesClassic<TDriver, TElement, TSelector> extends EyesClassic_base<TDriver, TElement, TSelector> {
    /**
     * Create a specialized version of this class
     * @template TDriver, TElement, TSelector
     * @param {Object} implementations - implementations of related classes
     * @param {string} implementations.agentId - base agent id
     * @param {EyesWrappedDriverCtor<TDriver, TElement, TSelector>} implementations.WrappedDriver - implementation for {@link EyesWrappedDriver}
     * @param {EyesWrappedElementCtor<TDriver, TElement, TSelector> & EyesWrappedElementStatics<TDriver, TElement, TSelector>} implementations.WrappedElement - implementation for {@link EyesWrappedElement}
     * @param {CheckSettings<TElement, TSelector>} implementations.CheckSettings - specialized version of {@link DriverCheckSettings}
     * @return {new (...args: ConstructorParameters<typeof EyesClassic>) => EyesClassic<TDriver, TElement, TSelector>} specialized version of this class
     */
    static specialize<TDriver_1, TElement_1, TSelector_1>({ agentId, WrappedDriver, WrappedElement, CheckSettings }: {
        agentId: string;
        WrappedDriver: new (logger: import("./logging/Logger"), driver: TDriver_1) => TDriver_1 & import("./wrappers/EyesWrappedDriver")<TDriver_1, TElement_1, TSelector_1>;
        WrappedElement: (new (logger?: import("./logging/Logger"), driver?: import("./wrappers/EyesWrappedDriver")<TDriver_1, TElement_1, TSelector_1>, element?: TElement_1, selector?: TSelector_1) => import("./wrappers/EyesWrappedElement")<TDriver_1, TElement_1, TSelector_1>) & import("./wrappers/EyesWrappedElement").EyesWrappedElementStatics<TDriver_1, TElement_1, TSelector_1>;
        CheckSettings: import("./fluent/DriverCheckSettings")<TElement_1, TSelector_1>;
    }): new (serverUrl?: string | boolean | import("./runner/ClassicRunner"), isDisabled?: boolean, runner?: import("./runner/ClassicRunner")) => import("./EyesClassic")<TDriver_1, TElement_1, TSelector_1>;
    /**
     * Creates a new (possibly disabled) Eyes instance that interacts with the Eyes Server at the specified url.
     * @param {string|boolean|ClassicRunner} [serverUrl=EyesBase.getDefaultServerUrl()] - Eyes server URL
     * @param {boolean} [isDisabled=false] - set to true to disable Applitools Eyes and use the webdriver directly
     * @param {ClassicRunner} [runner=new ClassicRunner()] - runner related to the wanted Eyes implementation
     */
    constructor(serverUrl?: string | boolean | import("./runner/ClassicRunner"), isDisabled?: boolean, runner?: import("./runner/ClassicRunner"));
    /** @private */
    private _runner;
    /** @type {EyesWrappedDriver<TDriver, TElement, TSelector>} */
    _driver: import("./wrappers/EyesWrappedDriver")<TDriver, TElement, TSelector>;
    /** @private @type {EyesJsExecutor<TDriver, TElement, TSelector>} */
    private _executor;
    /** @private @type {EyesElementFinder<TDriver, TElement, TSelector>} */
    private _finder;
    /** @private @type {EyesBrowsingContext<TDriver, TElement, TSelector>} */
    private _context;
    /** @private @type {EyesDriverController<TDriver, TElement, TSelector>} */
    private _controller;
    /** @private */
    private _imageRotationDegrees;
    /** @private */
    private _automaticRotation;
    /** @private @type {boolean} */
    private _isLandscape;
    /** @private @type {boolean} */
    private _checkFullFrameOrElement;
    /** @private @type {String} */
    private _originalDefaultContentOverflow;
    /** @private @type {String} */
    private _originalFrameOverflow;
    /** @private @type {String} */
    private _originalOverflow;
    /** @private @type {ImageProvider} */
    private _imageProvider;
    /** @private @type {RegionPositionCompensation} */
    private _regionPositionCompensation;
    /** @private @type {number} */
    private _devicePixelRatio;
    /** @private @type {PositionProvider} */
    private _targetPositionProvider;
    /** @private @type {EyesScreenshotFactory} */
    private _screenshotFactory;
    /** @private @type {Promise<void>} */
    private _closePromise;
    /**
     * @param {TDriver} driver - driver object for the specific framework
     * @param {String} [appName] - application name
     * @param {String} [testName] - test name
     * @param {RectangleSize|{width: number, height: number}} [viewportSize] - viewport size
     * @param {SessionType} [sessionType] - type of test (e.g.,  standard test / visual performance test).
     * @return {Promise<TDriver & EyesWrappedDriver<TDriver, TElement, TSelector>>}
     */
    open(driver: TDriver, appName?: string, testName?: string, viewportSize?: any | {
        width: number;
        height: number;
    }, sessionType?: any): Promise<TDriver & import("./wrappers/EyesWrappedDriver")<TDriver, TElement, TSelector>>;
    _userAgent: import("./useragent/UserAgent");
    /**
     * @param {string|CheckSettings<TElement, TSelector>} [nameOrCheckSettings] - name of the test case
     * @param {CheckSettings<TElement, TSelector>} [checkSettings] - check settings for the described test case
     * @returns {Promise<MatchResult>}
     */
    check(nameOrCheckSettings?: string | import("./fluent/DriverCheckSettings")<TElement, TSelector>, checkSettings?: import("./fluent/DriverCheckSettings")<TElement, TSelector>): Promise<import("./match/MatchResult")>;
    _checkSettings: import("./fluent/DriverCheckSettings")<TElement, TSelector>;
    /**
     * @private
     * @param {CheckSettings<TElement, TSelector>} checkSettings - check settings for the described test case
     * @param {Function} operation - check operation
     * @return {Promise<MatchResult>}
     */
    private _checkPrepare;
    _stitchContent: boolean;
    /**
     * @private
     * @param {CheckSettings<TElement, TSelector>} checkSettings - check settings for the described test case
     * @param {Region} targetRegion - region to check
     * @return {Promise<MatchResult>}
     */
    private _checkRegion;
    /**
     * @private
     * @param {CheckSettings<TElement, TSelector>} checkSettings - check settings for the described test case
     * @param {Region} targetRegion - region to check
     * @return {Promise<MatchResult>}
     */
    private _checkFullRegion;
    _shouldCheckFullRegion: boolean;
    _regionFullArea: import("./geometry/Region");
    /**
     * @private
     * @param {CheckSettings<TElement, TSelector>} checkSettings - check settings for the described test case
     * @param {EyesWrappedElement<TDriver, TElement, TSelector>} targetElement - element to check
     * @return {Promise<MatchResult>}
     */
    private _checkElement;
    /**
     * @private
     * @param {CheckSettings<TElement, TSelector>} checkSettings - check settings for the described test case
     * @param {EyesWrappedElement} targetElement - element to check
     * @return {Promise<MatchResult>}
     */
    private _checkFullElement;
    /**
     * @private
     * @param {CheckSettings<TElement, TSelector>} checkSettings - check settings for the described test case
     * @return {Promise<MatchResult>}
     */
    private _checkFrame;
    /**
     * @private
     * @param {CheckSettings<TElement, TSelector>} checkSettings - check settings for the described test case
     * @return {Promise<MatchResult>}
     */
    private _checkFullFrame;
    /**
     * @private
     * @param {EyesWrappedElement<TDriver, TElement, Selecotr>} scrollRootElement - scroll root element
     * @return {PositionProvider}
     */
    private _createPositionProvider;
    /**
     * Create a full region screenshot
     * @return {Promise<EyesScreenshot>}
     */
    _getFullRegionScreenshot(): Promise<import("./capture/EyesScreenshotNew")>;
    /**
     * Create a full page screenshot
     * @return {Promise<EyesScreenshot>}
     */
    _getFullPageScreenshot(): Promise<import("./capture/EyesScreenshotNew")>;
    /**
     * Create a viewport page screenshot
     * @return {Promise<EyesScreenshot>}
     */
    _getViewportScreenshot(): Promise<import("./capture/EyesScreenshotNew")>;
    /**
     * @private
     * @return {Promise<ScaleProviderFactory>}
     */
    private _updateScalingParams;
    /**
     * @private
     * @return {Promise<ScaleProviderFactory>}
     */
    private _getScaleProviderFactory;
    /**
     * Set the failure report.
     * @param {FailureReports} mode Use one of the values in FailureReports.
     */
    setFailureReport(mode: any): void;
    _failureReportOverridden: boolean;
    /**
     * @param {By} locator
     * @returns {Region}
     */
    getRegionByLocator(locator: any): import("./geometry/Region");
}
declare namespace EyesClassic {
    export { EyesWrappedDriver, EyesWrappedElement, EyesWrappedDriverCtor, EyesWrappedElementCtor, EyesWrappedElementStatics, EyesJsExecutor, EyesBrowsingContext, EyesElementFinder, EyesDriverController, CheckSettings };
}
type EyesWrappedDriver<TDriver, TElement, TSelector> = import("./wrappers/EyesWrappedDriver")<TDriver, TElement, TSelector>;
type CheckSettings<TElement, TSelector> = import("./fluent/DriverCheckSettings")<TElement, TSelector>;
type EyesWrappedDriverCtor<TDriver, TElement, TSelector> = new (logger: import("./logging/Logger"), driver: TDriver) => TDriver & import("./wrappers/EyesWrappedDriver")<TDriver, TElement, TSelector>;
type EyesWrappedElementCtor<TDriver, TElement, TSelector> = new (logger?: import("./logging/Logger"), driver?: import("./wrappers/EyesWrappedDriver")<TDriver, TElement, TSelector>, element?: TElement, selector?: TSelector) => import("./wrappers/EyesWrappedElement")<TDriver, TElement, TSelector>;
type EyesWrappedElementStatics<TDriver, TElement, TSelector> = {
    fromElement: (element: TElement) => import("./wrappers/EyesWrappedElement")<TDriver, TElement, TSelector>;
    fromSelector: (selector: TSelector) => import("./wrappers/EyesWrappedElement")<TDriver, TElement, TSelector>;
    isCompatible: (element: any) => element is TElement;
    isSelector: (selector: any) => selector is TSelector;
    toSupportedSelector: (selector: import("./wrappers/EyesWrappedElement").EyesSelector) => TSelector;
    toEyesSelector: (selector: TSelector) => import("./wrappers/EyesWrappedElement").EyesSelector;
    extractId: (element: TElement | import("./wrappers/EyesWrappedElement")<TDriver, TElement, TSelector>) => Promise<string>;
};
type EyesWrappedElement<TDriver, TElement, TSelector> = import("./wrappers/EyesWrappedElement")<TDriver, TElement, TSelector>;
type EyesJsExecutor<TDriver, TElement, TSelector> = import("./wrappers/EyesJsExecutor")<TDriver, TElement, TSelector>;
type EyesBrowsingContext<TDriver, TElement, TSelector> = import("./wrappers/EyesBrowsingContext")<TDriver, TElement, TSelector>;
type EyesElementFinder<TDriver, TElement, TSelector> = import("./wrappers/EyesElementFinder")<TDriver, TElement, TSelector>;
type EyesDriverController<TDriver, TElement, TSelector> = import("./wrappers/EyesDriverController")<TDriver, TElement, TSelector>;
