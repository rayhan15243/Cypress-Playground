export = EyesScreenshot;
/**
 * Class for handling screenshots.
 */
declare class EyesScreenshot {
    /**
     * Detect screenshot type of image
     * @param {MutableImage} image - actual screenshot image
     * @param {Eyes} eyes - eyes instance used to get the screenshot
     * @return {Promise<ScreenshotType>}
     */
    static getScreenshotType(image: MutableImage, eyes: any): Promise<ScreenshotType>;
    /**
     * Creates a frame(!) window screenshot
     * @param {Logger} logger - logger instance
     * @param {Eyes} eyes - eyes instance used to get the screenshot
     * @param {MutableImage} image - actual screenshot image
     * @param {RectangleSize} entireFrameSize - full internal size of the frame
     * @return {Promise<EyesScreenshot>}
     */
    static fromFrameSize(logger: Logger, eyes: any, image: MutableImage, entireFrameSize: import("../geometry/RectangleSize")): Promise<EyesScreenshot>;
    /**
     * Creates a frame(!) window screenshot from screenshot type and location
     * @param {Logger} logger - Logger instance
     * @param {Eyes} eyes - eyes instance used to get the screenshot
     * @param {MutableImage} image - actual screenshot image
     * @param {ScreenshotType} [screenshotType] - screenshot's type (e.g., viewport/full page)
     * @param {Location} [frameLocationInScreenshot] - current frame's location in the screenshot
     * @return {Promise<EyesScreenshot>}
     */
    static fromScreenshotType(logger: Logger, eyes: any, image: MutableImage, screenshotType?: ScreenshotType, frameLocationInScreenshot?: Location): Promise<EyesScreenshot>;
    /**
     * !WARNING! After creating new instance of EyesScreenshot, it should be initialized by calling
     * to init or initFromFrameSize method
     * @param {Logger} logger - logger instance
     * @param {Eyes} eyes - web eyes used to get the screenshot
     * @param {MutableImage} image - actual screenshot image
     */
    constructor(logger: Logger, eyes: any, image: MutableImage);
    _logger: import("../logging/Logger");
    _image: import("../images/MutableImage");
    _eyes: any;
    /** @type {FrameChain} */
    _frameChain: import("../frames/FrameChain");
    /** @type {ScreenshotType} */
    _screenshotType: ScreenshotType;
    /** @type {Location} */
    _currentFrameScrollPosition: Location;
    /**
     * The top/left coordinates of the frame window(!) relative to the top/left
     * of the screenshot. Used for calculations, so can also be outside(!) the screenshot.
     * @type {Location}
     */
    _frameLocationInScreenshot: Location;
    /** @type {RectangleSize} */
    _frameSize: import("../geometry/RectangleSize");
    /**
     * The top/left coordinates of the frame window(!) relative to the top/left
     * of the screenshot. Used for calculations, so can also be outside(!) the screenshot.
     * @type {Region}
     */
    _frameRect: import("../geometry/Region");
    /**
     * Creates a frame(!) window screenshot.
     * @param {RectangleSize} entireFrameSize - full internal size of the frame
     * @return {Promise<EyesScreenshot>}
     */
    initFromFrameSize(entireFrameSize: import("../geometry/RectangleSize")): Promise<EyesScreenshot>;
    /**
     * @param {ScreenshotType} [screenshotType] - screenshot's type (e.g., viewport/full page)
     * @return {Promise<EyesScreenshot>}
     */
    init(screenshotType?: ScreenshotType): Promise<EyesScreenshot>;
    /**
     * @return {MutableImage} - screenshot image
     */
    getImage(): MutableImage;
    /**
     * @return {Region} - region of the frame which is available in the screenshot, in screenshot coordinates
     */
    getFrameWindow(): import("../geometry/Region");
    /**
     * @return {FrameChain} - copy of the frame chain which was available when the screenshot was created
     */
    getFrameChain(): import("../frames/FrameChain");
    /**
     * @param {Location} location
     * @param {CoordinatesType} coordinatesType
     * @return {Location}
     */
    getLocationInScreenshot(location: Location, coordinatesType: any): Location;
    _location: Location;
    /**
     * @param {Region} region
     * @param {CoordinatesType} resultCoordinatesType
     * @return {Region}
     */
    getIntersectedRegion(region: import("../geometry/Region"), resultCoordinatesType: any): import("../geometry/Region");
    /**
     * @param {Region} region - region which location's coordinates needs to be converted.
     * @param {CoordinatesType} from - current coordinates type for {@code region}.
     * @param {CoordinatesType} to - target coordinates type for {@code region}.
     * @return {Region} new region which is the transformation of {@code region} to the {@code to} coordinates type.
     */
    convertRegionLocation(region: import("../geometry/Region"), from: any, to: any): import("../geometry/Region");
    /**
     * Converts a location's coordinates with the {@code from} coordinates type to the {@code to} coordinates type.
     * @param {Location} location - location which coordinates needs to be converted.
     * @param {CoordinatesType} from - current coordinates type for {@code location}.
     * @param {CoordinatesType} to - target coordinates type for {@code location}.
     * @return {Location} new location which is the transformation of {@code location} to the {@code to} coordinates type.
     */
    convertLocation(location: Location, from: any, to: any): Location;
    /**
     * Gets the elements region in the screenshot.
     * @param {EyesWrappedElement} element - element which region we want to intersect.
     * @return {Promise<Region>} intersected region, in {@code SCREENSHOT_AS_IS} coordinates type.
     */
    getIntersectedRegionFromElement(element: import("../wrappers/EyesWrappedElement")<any, any, any>): Promise<import("../geometry/Region")>;
    /**
     * Returns a part of the screenshot based on the given region.
     * @param {Region} region - region for which we should get the sub screenshot.
     * @param {Boolean} throwIfClipped - throw an EyesException if the region is not fully contained in the screenshot.
     * @return {Promise<EyesScreenshot>} screenshot instance containing the given region.
     */
    getSubScreenshot(region: import("../geometry/Region"), throwIfClipped: boolean): Promise<EyesScreenshot>;
}
declare namespace EyesScreenshot {
    export { ScreenshotTypes, Logger, MutableImage, EyesWrappedElement, ScreenshotType };
}
type ScreenshotType = number;
declare const Location: typeof import("../geometry/Location");
type MutableImage = import("../images/MutableImage");
type Logger = import("../logging/Logger");
/**
 * @typedef {import('../logging/Logger')} Logger
 * @typedef {import('../images/MutableImage')} MutableImage
 * @typedef {import('../wrappers/EyesWrappedElement')} EyesWrappedElement
 */
/**
 * @typedef {number} ScreenshotType
 */
declare const ScreenshotTypes: Readonly<{
    VIEWPORT: number;
    ENTIRE_FRAME: number;
}>;
type EyesWrappedElement = import("../wrappers/EyesWrappedElement")<any, any, any>;
