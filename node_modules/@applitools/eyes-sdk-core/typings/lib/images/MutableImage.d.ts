export = MutableImage;
/**
 * A wrapper for image buffer that parses it to BMP to allow editing and extracting its dimensions
 */
declare class MutableImage {
    /**
     * @param {number} width
     * @param {number} height
     * @return {MutableImage}
     */
    static newImage(width: number, height: number): MutableImage;
    /**
     * @param {Buffer|string} image - Encoded bytes of image (buffer or base64 string)
     */
    constructor(image: Buffer | string);
    /** @type {Buffer} */
    _imageBuffer: Buffer;
    /** @type {boolean} */
    _isParsed: boolean;
    /** @type {png.Image|Image} */
    _imageBmp: any | (new (width?: number, height?: number) => HTMLImageElement);
    /** @type {number} */
    _width: number;
    /** @type {number} */
    _height: number;
    /** @type {number} */
    _top: number;
    /** @type {number} */
    _left: number;
    /**
     * Coordinates represent the image's position in a larger context (if any).
     * E.g., A screenshot of the browser's viewport of a web page.
     *
     * @return {Location} - The coordinates of the image in the larger context (if any)
     */
    getCoordinates(): Location;
    /**
     * Coordinates represent the image's position in a larger context (if any).
     * E.g., A screenshot of the browser's viewport of a web page.
     *
     * @param {Location} coordinates
     */
    setCoordinates(coordinates: Location): void;
    /**
     * Size of the image. Parses the image if necessary
     *
     * @return {RectangleSize}
     */
    getSize(): import("../geometry/RectangleSize");
    /**
     * @return {number}
     */
    getWidth(): number;
    /**
     * @return {number}
     */
    getHeight(): number;
    /**
     * Return the image as buffer and image width and height.
     *
     * @return {Promise<{imageBuffer: Buffer, width: number, height: number}>}
     */
    asObject(): Promise<{
        imageBuffer: Buffer;
        width: number;
        height: number;
    }>;
    /**
     * Scales the image in place (used to downsize by 2 for retina display chrome bug - and tested accordingly).
     *
     * @param {number} scaleRatio
     * @return {Promise<MutableImage>}
     */
    scale(scaleRatio: number): Promise<MutableImage>;
    /**
     * Crops the image according to the given region.
     *
     * @param {Region} region
     * @return {Promise<MutableImage>}
     */
    crop(region: any): Promise<MutableImage>;
    /**
     * Crops the image according to the given region and return new image, do not override existing
     * !WARNING this method copy image and crop it. Use image.crop() when it is possible
     *
     * @param {Region} region
     * @return {Promise<MutableImage>}
     */
    getImagePart(region: any): Promise<MutableImage>;
    /**
     * Rotates an image clockwise by a number of degrees rounded to the nearest 90 degrees.
     *
     * @param {number} degrees - The number of degrees to rotate the image by
     * @return {Promise<MutableImage>}
     */
    rotate(degrees: number): Promise<MutableImage>;
    /**
     * @param {number} dx
     * @param {number} dy
     * @param {MutableImage} srcImage
     * @return {Promise}
     */
    copyRasterData(dx: number, dy: number, srcImage: MutableImage): Promise<any>;
    /**
     * @return {?Promise<Buffer>}
     */
    getImageBuffer(): Promise<Buffer> | null;
    /**
     * @return {?Promise<string>}
     */
    getImageBase64(): Promise<string> | null;
    /**
     * @return {?Promise<png.Image|Image>}
     */
    getImageData(): Promise<any | (new (width?: number, height?: number) => HTMLImageElement)> | null;
}
declare const Location: typeof import("../geometry/Location");
