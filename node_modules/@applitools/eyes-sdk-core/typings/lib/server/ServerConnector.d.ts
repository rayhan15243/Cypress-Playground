export = ServerConnector;
/**
 * Provides an API for communication with the Applitools server.
 */
declare class ServerConnector {
    /**
     * @param {Logger} logger
     * @param {Configuration} configuration
     */
    constructor({ logger, configuration, getAgentId }: any);
    _logger: any;
    _configuration: any;
    /** @type {RenderingInfo} */
    _renderingInfo: import("./RenderingInfo");
    _axios: any;
    /**
     * @return {RenderingInfo}
     */
    getRenderingInfo(): import("./RenderingInfo");
    /**
     * @param {RenderingInfo} renderingInfo
     */
    setRenderingInfo(renderingInfo: import("./RenderingInfo")): void;
    /**
     * Starts a new running session in the agent. Based on the given parameters, this running session will either be
     * linked to an existing session, or to a completely new session.
     *
     * @param {SessionStartInfo} sessionStartInfo - The start parameters for the session.
     * @return {Promise<RunningSession>} - RunningSession object which represents the current running session
     */
    startSession(sessionStartInfo: any): Promise<import("./RunningSession")>;
    /**
     * Stops the running session.
     *
     * @param {RunningSession} runningSession - The running session to be stopped.
     * @param {boolean} isAborted
     * @param {boolean} save
     * @return {Promise<TestResults>} - TestResults object for the stopped running session
     */
    stopSession(runningSession: import("./RunningSession"), isAborted: boolean, save: boolean): Promise<import("../TestResults")>;
    /**
     * Stops the running batch sessions.
     *
     * @param {string} batchId - The batchId to be stopped.
     * @return {Promise<void>}
     */
    deleteBatchSessions(batchId: string): Promise<void>;
    /**
     * Deletes the given test result
     *
     * @param {TestResults} testResults - The session to delete by test results.
     * @return {Promise}
     */
    deleteSession(testResults: import("../TestResults")): Promise<any>;
    uploadScreenshot(id: any, screenshot: any): Promise<string>;
    /**
     * Matches the current window (held by the WebDriver) to the expected window.
     *
     * @param {RunningSession} runningSession - The current agent's running session.
     * @param {MatchWindowData} matchWindowData - Encapsulation of a capture taken from the application.
     * @return {Promise<MatchResult>} - The results of the window matching.
     */
    matchWindow(runningSession: import("./RunningSession"), matchWindowData: any): Promise<import("../match/MatchResult")>;
    /**
     * Matches the current window in single request.
     *
     * @param {MatchSingleWindowData} matchSingleWindowData - Encapsulation of a capture taken from the application.
     * @return {Promise<TestResults>} - The results of the window matching.
     */
    matchSingleWindow(matchSingleWindowData: any): Promise<import("../TestResults")>;
    /**
     * Replaces an actual image in the current running session.
     *
     * @param {RunningSession} runningSession - The current agent's running session.
     * @param {number} stepIndex - The zero based index of the step in which to replace the actual image.
     * @param {MatchWindowData} matchWindowData - Encapsulation of a capture taken from the application.
     * @return {Promise<MatchResult>} - The results of the window matching.
     */
    replaceWindow(runningSession: import("./RunningSession"), stepIndex: number, matchWindowData: any): Promise<import("../match/MatchResult")>;
    /**
     * Initiate a rendering using RenderingGrid API
     *
     * @return {Promise<RenderingInfo>} - The results of the render request
     */
    renderInfo(): Promise<import("./RenderingInfo")>;
    batchInfo(batchId: any): Promise<any>;
    /**
     * Initiate a rendering using RenderingGrid API
     *
     * @param {RenderRequest[]|RenderRequest} renderRequest - The current agent's running session.
     * @return {Promise<RunningRender[]|RunningRender>} - The results of the render request
     */
    render(renderRequest: any[] | any): Promise<import("../renderer/RunningRender")[] | import("../renderer/RunningRender")>;
    /**
     * Check if resource exists on the server
     *
     * @param {RunningRender} runningRender - The running render (for second request only)
     * @param {RGridResource} resource - The resource to use
     * @return {Promise<boolean>} - Whether resource exists on the server or not
     */
    renderCheckResource(runningRender: import("../renderer/RunningRender"), resource: any): Promise<boolean>;
    /**
     * Upload resource to the server
     *
     * @param {RunningRender} runningRender - The running render (for second request only)
     * @param {RGridResource} resource - The resource to upload
     * @return {Promise<boolean>} - True if resource was uploaded
     */
    renderPutResource(runningRender: import("../renderer/RunningRender"), resource: any): Promise<boolean>;
    /**
     * Get the rendering status for current render
     *
     * @param {RunningRender} runningRender - The running render
     * @param {boolean} [delayBeforeRequest=false] - If {@code true}, then the request will be delayed
     * @return {Promise<RenderStatusResults>} - The render's status
     */
    renderStatus(runningRender: import("../renderer/RunningRender"), delayBeforeRequest?: boolean): Promise<import("../renderer/RenderStatusResults")>;
    /**
     * Get the rendering status for current render
     *
     * @param {string[]|string} renderId - The running renderId
     * @param {boolean} [delayBeforeRequest=false] - If {@code true}, then the request will be delayed
     * @return {Promise<RenderStatusResults[]|RenderStatusResults>} - The render's status
     */
    renderStatusById(renderId: string[] | string, delayBeforeRequest?: boolean): Promise<import("../renderer/RenderStatusResults")[] | import("../renderer/RenderStatusResults")>;
    /**
     * @param {string} domJson
     * @return {Promise<string>}
     */
    postDomSnapshot(id: any, domJson: string): Promise<string>;
    getUserAgents(): Promise<any>;
}
