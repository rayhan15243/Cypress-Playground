export = CheckSettings;
/**
 * @template TElement, TSelector
 * @typedef {new (checkSettings?: PlainCheckSettings<TElement, TSelector>) => CheckSettings<TElement, TSelector>} CheckSettingsCtor
 */
/**
 * @template TElement, TSelector
 * @typedef CheckSettingsStatics
 * @prop {(object: PlainCheckSettings<TElement, TSelector>) => CheckSettings<TElement, TSelector>} from
 * @prop {() => CheckSettings<TElement, TSelector>} window
 * @prop {(frame: FrameReference<TElement, TSelector>) => CheckSettings<TElement, TSelector>} frame
 * @prop {(region: RegionReference<TElement, TSelector>, frame?: FrameReference<TElement, TSelector>) => CheckSettings<TElement, TSelector>} region
 */
/**
 * @template TElement - TElement provided by wrapped framework
 * @template TSelector - TSelector supported by framework
 */
declare class CheckSettings<TElement, TSelector> {
    /**
     * @template TElement, TSelector
     * @param {SpecCheckSettings<TElement, TSelector>} spec
     * @return {CheckSettingsCtor<TElement, TSelector> & CheckSettingsStatics<TElement, TSelector>} specialized version of this class
     */
    static specialize<TElement_1, TSelector_1>(spec: SpecCheckSettings<TElement_1, TSelector_1>): (new (checkSettings?: PlainCheckSettings<TElement_1, TSelector_1>) => CheckSettings<TElement_1, TSelector_1>) & CheckSettingsStatics<TElement_1, TSelector_1>;
    /**
     * Create check settings from an object
     * @template TElement, TSelector
     * @param {PlainCheckSettings<TElement, TSelector>} object
     * @return {CheckSettings<TElement, TSelector>} check settings instance
     */
    static from<TElement_3, TSelector_3>(object: PlainCheckSettings<TElement_3, TSelector_3>): CheckSettings<TElement_3, TSelector_3>;
    /**
     * Create check settings without target
     * @template TElement, TSelector
     * @return {CheckSettings<TElement, TSelector>} check settings object
     */
    static window<TElement_4, TSelector_4>(): CheckSettings<TElement_4, TSelector_4>;
    /**
     * Create check settings with bound region and frame
     * @template TElement, TSelector
     * @param {RegionReference<TElement, TSelector>} region
     * @param {FrameReference<TElement, TSelector>} [frame]
     * @return {CheckSettings<TElement, TSelector>} check settings object
     */
    static region<TElement_5, TSelector_5>(region: import("../geometry/Region") | TElement_5 | TSelector_5 | import("../wrappers/EyesWrappedElement")<any, TElement_5, TSelector_5>, frame?: string | number | TElement_5 | TSelector_5 | import("../wrappers/EyesWrappedElement")<any, TElement_5, TSelector_5> | import("../frames/Frame")<any, TElement_5, TSelector_5>): CheckSettings<TElement_5, TSelector_5>;
    /**
     * Create check settings with bound frame
     * @template TElement, TSelector
     * @param {FrameReference<TElement, TSelector>} frame
     * @return {CheckSettings<TElement, TSelector>} check settings object
     */
    static frame<TElement_6, TSelector_6>(frame: string | number | TElement_6 | TSelector_6 | import("../frames/Frame")<any, TElement_6, TSelector_6> | import("../wrappers/EyesWrappedElement")<any, TElement_6, TSelector_6>): CheckSettings<TElement_6, TSelector_6>;
    /**
     * Create check settings with bound region and/or frame
     * @param {PlainCheckSettings<TElement, TSelector>} [checkSettings]
     */
    constructor(checkSettings?: PlainCheckSettings<TElement, TSelector>);
    /** @type {SpecCheckSettings<TElement, TSelector>} */
    get spec(): SpecCheckSettings<TElement, TSelector>;
    /** @private @type {EyesWrappedElement<TElement, TSelector>} */
    private _targetElement;
    /** @private @type {Region} */
    private _targetRegion;
    /** @private @type {Frame<TElement, TSelector>[]} */
    private _frameChain;
    /** @private @type {GetRegion[]} */
    private _ignoreRegions;
    /** @private @type {GetRegion[]} */
    private _layoutRegions;
    /** @private @type {GetRegion[]} */
    private _strictRegions;
    /** @private @type {GetRegion[]} */
    private _contentRegions;
    /** @private @type {GetFloatingRegion[]} */
    private _floatingRegions;
    /** @private @type {GetAccessibilityRegion[]} */
    private _accessibilityRegions;
    /** @private @type {EyesWrappedElement<TElement, TSelector>} */
    private _scrollRootElement;
    /** @private @type {string} */
    private _name;
    /** @private @type {number} */
    private _timeout;
    /** @private @type {boolean} */
    private _sendDom;
    /** @private @type {MatchLevel} */
    private _matchLevel;
    /** @private @type {AccessibilityLevel} */
    private _accessibilityLevel;
    /** @private @type {boolean} */
    private _useDom;
    /** @private @type {boolean} */
    private _enablePatterns;
    /** @private @type {boolean} */
    private _ignoreDisplacements;
    /** @private @type {boolean} */
    private _ignoreCaret;
    /** @private @type {boolean} */
    private _stitchContent;
    /** @private @type {string} */
    private _renderId;
    /** @private @type {Object<string, string>} */
    private _scriptHooks;
    /**
     * @param {RegionReference<TElement, TSelector>} region
     * @return {this}
     */
    region(region: import("../geometry/Region") | TElement | TSelector | import("../wrappers/EyesWrappedElement")<any, TElement, TSelector>): this;
    /**
     * @private
     * @return {TargetRegionByElement}
     */
    private getTargetProvider;
    /**
     * @private
     * @return {Region}
     */
    private getTargetRegion;
    /**
     * @private
     * @type {EyesWrappedElement<TElement, TSelector>}
     */
    private get targetElement();
    /**
     * @param {FrameReference<TElement, TSelector>} frameReference - the frame to switch to
     * @return {this}
     */
    frame(frameReference: string | number | TElement | TSelector | import("../wrappers/EyesWrappedElement")<any, TElement, TSelector> | import("../frames/Frame")<any, TElement, TSelector>): this;
    /**
     * @private
     * @return {Frame<TElement, TSelector>[]}
     */
    private getFrameChain;
    /**
     * @private
     * @type {Frame<TElement, TSelector>[]}
     */
    private get frameChain();
    /**
     * Adds a region to ignore
     * @param {RegionReference<TElement, TSelector>} region - region reference to ignore when validating the screenshot
     * @return {this} this instance for chaining
     */
    ignoreRegion(region: import("../geometry/Region") | TElement | TSelector | import("../wrappers/EyesWrappedElement")<any, TElement, TSelector>): this;
    /**
     * Adds a region to ignore
     * @param {RegionReference<TElement, TSelector>} region - region reference to ignore when validating the screenshot
     * @return {this} this instance for chaining
     */
    ignore(region: import("../geometry/Region") | TElement | TSelector | import("../wrappers/EyesWrappedElement")<any, TElement, TSelector>): this;
    /**
     * Adds one or more ignore regions.
     * @param {RegionReference<TElement, TSelector>[]} regions - region references to ignore when validating the screenshot.
     * @return {this} this instance of the settings object.
     */
    ignoreRegions(...regions: (import("../geometry/Region") | TElement | TSelector | import("../wrappers/EyesWrappedElement")<any, TElement, TSelector>)[]): this;
    /**
     * Adds one or more ignore regions.
     * @param {RegionReference<TElement, TSelector>[]} regions - region references to ignore when validating the screenshot.
     * @return {this} this instance of the settings object.
     */
    ignores(...regions: (import("../geometry/Region") | TElement | TSelector | import("../wrappers/EyesWrappedElement")<any, TElement, TSelector>)[]): this;
    /**
     * @private
     * @return {GetRegion[]}
     */
    private getIgnoreRegions;
    /**
     * Adds a layout region
     * @param {RegionReference<TElement, TSelector>} region - region reference to match as layout when validating the screenshot
     * @return {this} this instance for chaining
     */
    layoutRegion(region: import("../geometry/Region") | TElement | TSelector | import("../wrappers/EyesWrappedElement")<any, TElement, TSelector>): this;
    /**
     * Adds one or more layout regions.
     * @param {RegionReference<TElement, TSelector>[]} regions - region references to match using the Layout method.
     * @return {this} this instance of the settings object.
     */
    layoutRegions(...regions: (import("../geometry/Region") | TElement | TSelector | import("../wrappers/EyesWrappedElement")<any, TElement, TSelector>)[]): this;
    /**
     * @private
     * @return {GetRegion[]}
     */
    private getLayoutRegions;
    /**
     * Adds a strict region
     * @param {RegionReference<TElement, TSelector>} region - region reference to match as strict when validating the screenshot
     * @return {this} this instance for chaining
     */
    strictRegion(region: import("../geometry/Region") | TElement | TSelector | import("../wrappers/EyesWrappedElement")<any, TElement, TSelector>): this;
    /**
     * @private
     * @return {GetRegion[]}
     */
    private getStrictRegions;
    /**
     * Adds one or more strict regions.
     * @param {RegionReference<TElement, TSelector>[]} regions - region references to match using the Strict method.
     * @return {this} this instance of the settings object.
     */
    strictRegions(...regions: (import("../geometry/Region") | TElement | TSelector | import("../wrappers/EyesWrappedElement")<any, TElement, TSelector>)[]): this;
    /**
     * Adds a content region
     * @param {RegionReference<TElement, TSelector>} region - region reference to match as content when validating the screenshot
     * @return {this} this instance for chaining
     */
    contentRegion(region: import("../geometry/Region") | TElement | TSelector | import("../wrappers/EyesWrappedElement")<any, TElement, TSelector>): this;
    /**
     * Adds one or more content regions.
     * @param {RegionReference<TElement, TSelector>[]} regions - region references to match using the Content method.
     * @return {this} this instance of the settings object.
     */
    contentRegions(...regions: (import("../geometry/Region") | TElement | TSelector | import("../wrappers/EyesWrappedElement")<any, TElement, TSelector>)[]): this;
    /**
     * @private
     * @return {GetRegion[]}
     */
    private getContentRegions;
    /**
     * Adds a floating region. A floating region is a a region that can be placed within the boundaries
     * of a bigger region
     * @param {RegionReference<TElement, TSelector>} region - region reference to mark as float when validating the screenshot
     * @param {number} [maxUpOffset] - how much the content can move up
     * @param {number} [maxDownOffset] - how much the content can move down
     * @param {number} [maxLeftOffset] - how much the content can move to the left
     * @param {number} [maxRightOffset] - how much the content can move to the right
     * @return {this} this instance for chaining
     */
    floatingRegion(region: import("../geometry/Region") | TElement | TSelector | import("../wrappers/EyesWrappedElement")<any, TElement, TSelector>, maxUpOffset?: number, maxDownOffset?: number, maxLeftOffset?: number, maxRightOffset?: number): this;
    /**
     * Adds a floating region. A floating region is a a region that can be placed within the boundaries
     * of a bigger region
     * @param {RegionReference<TElement, TSelector>} region - region reference to mark as float when validating the screenshot
     * @param {number} [maxUpOffset] - how much the content can move up
     * @param {number} [maxDownOffset] - how much the content can move down
     * @param {number} [maxLeftOffset] - how much the content can move to the left
     * @param {number} [maxRightOffset] - how much the content can move to the right
     * @return {this} this instance for chaining
     */
    floating(region: import("../geometry/Region") | TElement | TSelector | import("../wrappers/EyesWrappedElement")<any, TElement, TSelector>, maxUpOffset?: number, maxDownOffset?: number, maxLeftOffset?: number, maxRightOffset?: number): this;
    /**
     * Adds one or more floating regions. A floating region is a a region that can be placed within the boundaries
     * of a bigger region.
     * @param {number} maxOffset - how much each of the content rectangles can move in any direction.
     * @param {RegionReference<TElement, TSelector>[]} regions - one or more content rectangles or region containers
     * @return {this} this instance of the settings object.
     */
    floatingRegions(maxOffset: number, ...regions: (import("../geometry/Region") | TElement | TSelector | import("../wrappers/EyesWrappedElement")<any, TElement, TSelector>)[]): this;
    /**
     * Adds one or more floating regions. A floating region is a a region that can be placed within the boundaries
     * of a bigger region.
     * @param {number} maxOffset - how much each of the content rectangles can move in any direction.
     * @param {RegionReference<TElement, TSelector>[]} regions - one or more content rectangles or region containers
     * @return {this} this instance of the settings object.
     */
    floatings(maxOffset: number, ...regions: (import("../geometry/Region") | TElement | TSelector | import("../wrappers/EyesWrappedElement")<any, TElement, TSelector>)[]): this;
    /**
     * @private
     * @return {GetFloatingRegion[]}
     */
    private getFloatingRegions;
    /**
     * Adds an accessibility region. An accessibility region is a region that has an accessibility type
     * @param {RegionReference<TElement, TSelector>} region - region reference of content rectangle or region container
     * @param {AccessibilityRegionType} [regionType] - type of accessibility
     * @return {this} this instance for chaining
     */
    accessibilityRegion(region: import("../geometry/Region") | TElement | TSelector | import("../wrappers/EyesWrappedElement")<any, TElement, TSelector>, regionType?: any): this;
    /**
     * Adds an accessibility region. An accessibility region is a region that has an accessibility type
     * @param {RegionReference<TElement, TSelector>} region - region reference of content rectangle or region container
     * @param {AccessibilityRegionType} [regionType] - type of accessibility
     * @return {this} this instance for chaining
     */
    accessibility(region: import("../geometry/Region") | TElement | TSelector | import("../wrappers/EyesWrappedElement")<any, TElement, TSelector>, regionType?: any): this;
    /**
     * @private
     * @return {GetAccessibilityRegion[]}
     */
    private getAccessibilityRegions;
    /**
     * @param {ElementReference<TElement, TSelector>} element
     * @return {this}
     */
    scrollRootElement(element: TElement | TSelector | import("../wrappers/EyesWrappedElement")<any, TElement, TSelector>): this;
    /**
     * @private
     * @return {Promise<EyesWrappedElement<TElement, TSelector>>}
     */
    private getScrollRootElement;
    /**
     * A setter for the checkpoint name.
     * @param {string} name - A name by which to identify the checkpoint.
     * @return {this} - This instance of the settings object.
     */
    withName(name: string): this;
    /**
     * @private
     * @return {string}
     */
    private getName;
    /**
     * Defines whether to send the document DOM or not.
     * @param {boolean} [sendDom=true] - When {@code true} sends the DOM to the server (the default).
     * @return {this} - This instance of the settings object.
     */
    sendDom(sendDom?: boolean): this;
    /**
     * @private
     * @return {boolean}
     */
    private getSendDom;
    /**
     * Set the render ID of the screenshot.
     * @param {string} renderId - The render ID to use.
     * @return {this} - This instance of the settings object.
     */
    renderId(renderId: string): this;
    /**
     * @private
     * @return {string}
     */
    private getRenderId;
    /**
     * Set the match level by which to compare the screenshot.
     * @param {MatchLevel} matchLevel - The match level to use.
     * @return {this} - This instance of the settings object.
     */
    matchLevel(matchLevel: any): this;
    /**
     * Shortcut to set the match level to {@code MatchLevel.LAYOUT}.
     * @return {this} - This instance of the settings object.
     */
    layout(): this;
    /**
     * Shortcut to set the match level to {@code MatchLevel.EXACT}.
     * @return {this} - This instance of the settings object.
     */
    exact(): this;
    /**
     * Shortcut to set the match level to {@code MatchLevel.STRICT}.
     * @return {this} - This instance of the settings object.
     */
    strict(): this;
    /**
     * Shortcut to set the match level to {@code MatchLevel.CONTENT}.
     * @return {this} - This instance of the settings object.
     */
    content(): this;
    /**
     * @private
     * @return {MatchLevel}
     */
    private getMatchLevel;
    /**
     * Defines if to detect and ignore a blinking caret in the screenshot.
     * @param {boolean} [ignoreCaret=true] - Whether or not to detect and ignore a blinking caret in the screenshot.
     * @return {this} - This instance of the settings object.
     */
    ignoreCaret(ignoreCaret?: boolean): this;
    /**
     * @private
     * @return {boolean}
     */
    private getIgnoreCaret;
    /**
     * Defines that the screenshot will contain the entire element or region, even if it's outside the view.
     * @param {boolean} [fully=true]
     * @return {this} - This instance of the settings object.
     */
    fully(fully?: boolean): this;
    /**
     * @param {boolean} [stitchContent=true]
     * @return {this}
     */
    stitchContent(stitchContent?: boolean): this;
    /**
     * @private
     * @return {boolean}
     */
    private getStitchContent;
    /**
     * Defines useDom for enabling the match algorithm to use dom.
     * @param {boolean} [useDom=true]
     * @return {this} - This instance of the settings object.
     */
    useDom(useDom?: boolean): this;
    /**
     * @private
     * @return {boolean}
     */
    private getUseDom;
    /**
     * Enabling the match algorithms for pattern detection
     * @param {boolean} [enablePatterns=true]
     * @return {this} - This instance of the settings object.
     */
    enablePatterns(enablePatterns?: boolean): this;
    /**
     * @private
     * @return {boolean}
     */
    private getEnablePatterns;
    /**
     * @param {boolean} [ignoreDisplacements=true]
     * @return {this} - This instance of the settings object.
     */
    ignoreDisplacements(ignoreDisplacements?: boolean): this;
    /**
     * @private
     * @return {boolean}
     */
    private getIgnoreDisplacements;
    /**
     * Defines the timeout to use when acquiring and comparing screenshots.
     * @param {number} timeoutMilliseconds - The timeout to use in milliseconds.
     * @return {this} - This instance of the settings object.
     */
    timeout(timeoutMilliseconds?: number): this;
    /**
     * @private
     * @return {number}
     */
    private getTimeout;
    /**
     * @param {string} name
     * @param {string} script
     * @return {this}
     */
    hook(name: string, script: string): this;
    /**
     * @param {String} hook
     * @return {this}
     */
    beforeRenderScreenshotHook(hook: string): this;
    /**
     * @deprecated
     * @param {String} hook
     * @return {this}
     */
    webHook(hook: string): this;
    /**
     * @private
     * @return {Map<string, string>}
     */
    private getScriptHooks;
    /**
     * @override
     */
    toString(): string;
    /**
     * @private
     */
    private _getTargetType;
    /**
     * @private
     */
    private toCheckWindowConfiguration;
    /**
     * @private
     */
    private _getPersistedRegions;
}
declare namespace CheckSettings {
    export { Region, EyesWrappedElement, Frame, FrameReference, ElementReference, RegionReference, FloatingRegionReference, AccessibilityRegionReference, PlainCheckSettings, SpecCheckSettings, CheckSettingsCtor, CheckSettingsStatics };
}
type SpecCheckSettings<TElement, TSelector> = {
    /**
     * - return true if the value is a valid selector, false otherwise
     */
    isSelector: (selector: any) => boolean;
    /**
     * - return true if the value is an element, false otherwise
     */
    isCompatibleElement: (element: any) => boolean;
    /**
     * - return true if the value is a frame reference, false otherwise
     */
    isFrameReference: (reference: any) => boolean;
    /**
     * - return partially created element
     */
    createElementFromSelector: (selector: TSelector) => import("../wrappers/EyesWrappedElement")<any, TElement, TSelector>;
    /**
     * - return partially created element
     */
    createElementFromElement: (element: TElement) => import("../wrappers/EyesWrappedElement")<any, TElement, TSelector>;
    /**
     * - return frame reference
     */
    createFrameReference: (reference: string | number | TElement | TSelector | import("../wrappers/EyesWrappedElement")<any, TElement, TSelector> | import("../frames/Frame")<any, TElement, TSelector>) => import("../frames/Frame")<any, TElement, TSelector>;
};
type RegionReference<TElement, TSelector> = import("../geometry/Region") | TElement | TSelector | import("../wrappers/EyesWrappedElement")<any, TElement, TSelector>;
type FrameReference<TElement, TSelector> = string | number | TElement | TSelector | import("../frames/Frame")<any, TElement, TSelector> | import("../wrappers/EyesWrappedElement")<any, TElement, TSelector>;
type ElementReference<TElement, TSelector> = TElement | TSelector | import("../wrappers/EyesWrappedElement")<any, TElement, TSelector>;
type CheckSettingsCtor<TElement, TSelector> = new (checkSettings?: PlainCheckSettings<TElement, TSelector>) => CheckSettings<TElement, TSelector>;
type CheckSettingsStatics<TElement, TSelector> = {
    from: (object: PlainCheckSettings<TElement, TSelector>) => CheckSettings<TElement, TSelector>;
    window: () => CheckSettings<TElement, TSelector>;
    frame: (frame: string | number | TElement | TSelector | import("../frames/Frame")<any, TElement, TSelector> | import("../wrappers/EyesWrappedElement")<any, TElement, TSelector>) => CheckSettings<TElement, TSelector>;
    region: (region: import("../geometry/Region") | TElement | TSelector | import("../wrappers/EyesWrappedElement")<any, TElement, TSelector>, frame?: string | number | TElement | TSelector | import("../frames/Frame")<any, TElement, TSelector> | import("../wrappers/EyesWrappedElement")<any, TElement, TSelector>) => CheckSettings<TElement, TSelector>;
};
type PlainCheckSettings<TElement, TSelector> = {
    name?: string;
    matchLevel?: any;
    timeout?: number;
    sendDom?: boolean;
    useDom?: boolean;
    enablePatterns?: boolean;
    ignoreDisplacements?: boolean;
    ignoreCaret?: boolean;
    isFully?: boolean;
    renderId?: string;
    hooks?: {
        [key: string]: string;
    };
    region?: import("../geometry/Region") | TElement | TSelector | import("../wrappers/EyesWrappedElement")<any, TElement, TSelector>;
    frames?: (string | number | TElement | TSelector | import("../wrappers/EyesWrappedElement")<any, TElement, TSelector> | import("../frames/Frame")<any, TElement, TSelector> | {
        frame: string | number | TElement | TSelector | import("../wrappers/EyesWrappedElement")<any, TElement, TSelector> | import("../frames/Frame")<any, TElement, TSelector>;
        scrollRootElement?: TElement | TSelector | import("../wrappers/EyesWrappedElement")<any, TElement, TSelector>;
    })[];
    scrollRootElement?: TElement | TSelector | import("../wrappers/EyesWrappedElement")<any, TElement, TSelector>;
    ignoreRegions?: (import("../geometry/Region") | TElement | TSelector | import("../wrappers/EyesWrappedElement")<any, TElement, TSelector>)[];
    layoutRegion?: (import("../geometry/Region") | TElement | TSelector | import("../wrappers/EyesWrappedElement")<any, TElement, TSelector>)[];
    strictRegions?: (import("../geometry/Region") | TElement | TSelector | import("../wrappers/EyesWrappedElement")<any, TElement, TSelector>)[];
    contentRegions?: (import("../geometry/Region") | TElement | TSelector | import("../wrappers/EyesWrappedElement")<any, TElement, TSelector>)[];
    floatingRegions?: (import("../geometry/Region") | TElement | TSelector | import("../wrappers/EyesWrappedElement")<any, TElement, TSelector> | FloatingRegionReference<TElement, TSelector>)[];
    accessibilityRegions?: (import("../geometry/Region") | TElement | TSelector | import("../wrappers/EyesWrappedElement")<any, TElement, TSelector> | AccessibilityRegionReference<TElement, TSelector>)[];
};
type Region = import("../geometry/Region");
type EyesWrappedElement<TElement, TSelector> = import("../wrappers/EyesWrappedElement")<any, TElement, TSelector>;
type Frame<TElement, TSelector> = import("../frames/Frame")<any, TElement, TSelector>;
type FloatingRegionReference<TElement, TSelector> = {
    region: import("../geometry/Region") | TElement | TSelector | import("../wrappers/EyesWrappedElement")<any, TElement, TSelector>;
    /**
     * - how much the content can move up
     */
    maxUpOffset?: number;
    /**
     * - how much the content can move down
     */
    maxDownOffset?: number;
    /**
     * - how much the content can move to the left
     */
    maxLeftOffset?: number;
    /**
     * - how much the content can move to the right
     */
    maxRightOffset?: number;
};
type AccessibilityRegionReference<TElement, TSelector> = {
    region: import("../geometry/Region") | TElement | TSelector | import("../wrappers/EyesWrappedElement")<any, TElement, TSelector>;
    type?: any;
};
